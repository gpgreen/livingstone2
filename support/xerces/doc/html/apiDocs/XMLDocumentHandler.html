<html><head><TITLE>XMLDocumentHandler</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class   XMLDocumentHandler  </H2><BLOCKQUOTE>

This abstract class provides the interface for the scanner to return
XML document information up to the parser as it scans through the
document
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=95>
<param name=classes value="CXMLDocumentHandler,MXMLDocumentHandler.html,CSAXParser,MSAXParser.html,CDOMParser,MDOMParser.html">
<param name=before value="M,M|_,Mr_">
<param name=after value="M,M,M">
<param name=indent value="0,0,0">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<TABLE>
<DT><h3>Public</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.44.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Destructor </B> <br>
<I></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>The document handler interface </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.44.1.1"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>docCharacters</B> ( const XMLCh* const chars, const unsigned int length, const bool cdataSection )<br>
<I>Receive notification of character data</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.2"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>docComment</B> ( const XMLCh* const comment )<br>
<I>Receive notification of comments in the XML content being parsed</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.3"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>docPI</B> ( const XMLCh* const target, const XMLCh* const data )<br>
<I>Receive notification of PI's parsed in the XML content</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.4"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>endDocument</B> ()<br>
<I>Receive notification after the scanner has parsed the end of the
document</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.5"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>endElement</B> ( const <!1><A HREF="XMLElementDecl.html">XMLElementDecl</A>& elemDecl, const unsigned int uriId, const bool isRoot )<br>
<I>Receive notification of the end of an element</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.6"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>endEntityReference</B> ( const <!1><A HREF="XMLEntityDecl.html">XMLEntityDecl</A>& entDecl )<br>
<I>Receive notification when a referenced entity's content ends

This method is called when scanner encounters the end of an entity
reference</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.7"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>ignorableWhitespace</B> ( const XMLCh* const chars, const unsigned int length, const bool cdataSection )<br>
<I>Receive notification of ignorable whitespace in element content</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.8"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>resetDocument</B> ()<br>
<I>Reset the document handler's state, if required

This method is used to give the registered document handler a
chance to reset itself</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.9"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>startDocument</B> ()<br>
<I>Receive notification of the start of a new document

This method is the first callback called the scanner at the
start of every parse</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.10"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>startElement</B> ( const <!1><A HREF="XMLElementDecl.html">XMLElementDecl</A>& elemDecl, const unsigned int uriId, const XMLCh* const prefixName, const RefVectorOf<<!1><A HREF="XMLAttr.html">XMLAttr</A>>& attrList, const unsigned int attrCount, const bool isEmpty, const bool isRoot )<br>
<I>Receive notification of a new start tag

This method is called when scanner encounters the start of an element tag</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.11"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>startEntityReference</B> (const <!1><A HREF="XMLEntityDecl.html">XMLEntityDecl</A>& entDecl)<br>
<I>Receive notification when the scanner hits an entity reference</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.44.1.12"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>XMLDecl</B> ( const XMLCh* const versionStr, const XMLCh* const encodingStr, const XMLCh* const standaloneStr, const XMLCh* const autoEncodingStr )<br>
<I>Receive notification of an XML declaration

Currently neither DOM nor SAX provide API's to return back this
information</I>
</TD></TR>
</TABLE>
</TD></TR></TABLE></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

This abstract class provides the interface for the scanner to return
XML document information up to the parser as it scans through the
document. 

The interface is very similar to org.sax.DocumentHandler, but
has some extra methods required to get all the data out.

</BLOCKQUOTE>
<DL>

<A NAME="Destructor ">
<A NAME ="DOC.44.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Destructor </B></TT>
<DL></DL><P>
<A NAME="The document handler interface ">
<A NAME ="DOC.44.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  The document handler interface </B></TT>
<DL></DL><P><DL>

<A NAME="docCharacters">
<A NAME ="DOC.44.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  docCharacters( const XMLCh* const chars, const unsigned int length, const bool cdataSection )</B></TT>
<DD>Receive notification of character data.

<p>The scanner will call this method to report each chunk of
character data. The scanner may return all contiguous character
data in a single chunk, or they may split it into several
chunks; however, all of the characters in any single event
will come from the same external entity, so that the Locator
provides useful information.</p>

<p>The parser must not attempt to read from the array
outside of the specified range.</p>


<DL><DT><B>Parameters:</B><DD><B>chars</B> -            The content (characters) between markup from the XML
document.
<br><B>length</B> -           The number of characters to read from the array.
<br><B>cdataSection</B> -     Indicates that this data is inside a CDATA
section.
<br><DT><B>See Also:</B><DD><A HREF="#ignorableWhitespace">ignorableWhitespace</A> 
<br><!1><A HREF="Locator.html">Locator</A><br></DL><P>
<A NAME="docComment">
<A NAME ="DOC.44.1.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  docComment( const XMLCh* const comment )</B></TT>
<DD>Receive notification of comments in the XML content being parsed.

This scanner will call this method for any comments found in the
content of the document.


<DL><DT><B>Parameters:</B><DD><B>comment</B> -  The text of the comment.<br></DL><P>
<A NAME="docPI">
<A NAME ="DOC.44.1.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  docPI( const XMLCh* const target, const XMLCh* const data )</B></TT>
<DD>Receive notification of PI's parsed in the XML content.

The scanner will call this method for any PIs it finds within the
content of the document.


<DL><DT><B>Parameters:</B><DD><B>target</B> -   The name of the PI.
<br><B>data</B> -     The body of the PI. This may be an empty string since
the body is optional.<br></DL><P>
<A NAME="endDocument">
<A NAME ="DOC.44.1.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  endDocument()</B></TT>
<DD>Receive notification after the scanner has parsed the end of the
document.

The scanner will call this method when the current document has been
fully parsed. The handler may use this opportunity to do something with
the data, clean up temporary data, etc...
<DL></DL><P>
<A NAME="endElement">
<A NAME ="DOC.44.1.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  endElement( const <!1><A HREF="XMLElementDecl.html">XMLElementDecl</A>& elemDecl, const unsigned int uriId, const bool isRoot )</B></TT>
<DD>Receive notification of the end of an element.

This method is called when scanner encounters the end of element tag.
There will be a corresponding startElement() event for every
endElement() event, but not necessarily the other way around. For
empty tags, there is only a startElement() call.


<DL><DT><B>Parameters:</B><DD><B>elementDecl</B> -  The name of the element whose end tag was just
parsed.
<br><B>uriId</B> -        The ID of the URI in the URI pool (only valid if 
name spaces is enabled)
<br><B>isRoot</B> -       Indicates if this is the root element.<br></DL><P>
<A NAME="endEntityReference">
<A NAME ="DOC.44.1.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  endEntityReference( const <!1><A HREF="XMLEntityDecl.html">XMLEntityDecl</A>& entDecl )</B></TT>
<DD>Receive notification when a referenced entity's content ends

This method is called when scanner encounters the end of an entity
reference.


<DL><DT><B>Parameters:</B><DD><B>entityName</B> -   The name of the entity reference just scanned.<br></DL><P>
<A NAME="ignorableWhitespace">
<A NAME ="DOC.44.1.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  ignorableWhitespace( const XMLCh* const chars, const unsigned int length, const bool cdataSection )</B></TT>
<DD>Receive notification of ignorable whitespace in element content.

<p>Validating Parsers must use this method to report each chunk
of ignorable whitespace (see the W3C XML 1.0 recommendation,
section 2.10): non-validating parsers may also use this method
if they are capable of parsing and using content models.</p>

<p>The scanner may return all contiguous whitespace in a single
chunk, or it may split it into several chunks; however, all of
the characters in any single event will come from the same
external entity, so that the Locator provides useful
information.</p>

<p>The parser must not attempt to read from the array
outside of the specified range.</p>


<DL><DT><B>Parameters:</B><DD><B>chars</B> -        The whitespace characters from the XML document.
<br><B>length</B> -       The number of characters to read from the array.
<br><B>cdataSection</B> -  Indicates that this data is inside a CDATA
section.
<br><DT><B>See Also:</B><DD><A HREF="#characters">characters</A><br></DL><P>
<A NAME="resetDocument">
<A NAME ="DOC.44.1.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  resetDocument()</B></TT>
<DD>Reset the document handler's state, if required

This method is used to give the registered document handler a
chance to reset itself. Its called by the scanner at the start of
every parse.
<DL></DL><P>
<A NAME="startDocument">
<A NAME ="DOC.44.1.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  startDocument()</B></TT>
<DD>Receive notification of the start of a new document

This method is the first callback called the scanner at the
start of every parse. This is before any content is parsed.
<DL></DL><P>
<A NAME="startElement">
<A NAME ="DOC.44.1.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  startElement( const <!1><A HREF="XMLElementDecl.html">XMLElementDecl</A>& elemDecl, const unsigned int uriId, const XMLCh* const prefixName, const RefVectorOf<<!1><A HREF="XMLAttr.html">XMLAttr</A>>& attrList, const unsigned int attrCount, const bool isEmpty, const bool isRoot )</B></TT>
<DD>Receive notification of a new start tag

This method is called when scanner encounters the start of an element tag.
All elements must always have a startElement() tag. Empty tags will
only have the startElement() tag and no endElement() tag.


<DL><DT><B>Parameters:</B><DD><B>elementDecl</B> -  The name of the element whose start tag was just
parsed.
<br><B>uriId</B> -        The ID of the URI in the URI pool (only valid if 
name spaces is enabled)
<br><B>prefixName</B> -   The string representing the prefix name
<br><B>attrList</B> -     List of attributes in the element
<br><B>attrCount</B> -    Count of the attributes in the element
<br><B>isEmpty</B> -      Indicates if the element is empty, in which case
you should not expect an endElement() event.
<br><B>isRoot</B> -       Indicates if this is the root element.<br></DL><P>
<A NAME="startEntityReference">
<A NAME ="DOC.44.1.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  startEntityReference(const <!1><A HREF="XMLEntityDecl.html">XMLEntityDecl</A>& entDecl)</B></TT>
<DD>Receive notification when the scanner hits an entity reference.

This is currently useful only to DOM parser configurations as SAX
does not provide any api to return this information.


<DL><DT><B>Parameters:</B><DD><B>entityName</B> -   The name of the entity that was referenced.<br></DL><P>
<A NAME="XMLDecl">
<A NAME ="DOC.44.1.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  XMLDecl( const XMLCh* const versionStr, const XMLCh* const encodingStr, const XMLCh* const standaloneStr, const XMLCh* const autoEncodingStr )</B></TT>
<DD>Receive notification of an XML declaration

Currently neither DOM nor SAX provide API's to return back this
information.


<DL><DT><B>Parameters:</B><DD><B>versionStr</B> -       The value of the <code>version</code> attribute
of the XML decl.
<br><B>encodingStr</B> -      The value of the <code>encoding</code> attribute
of the XML decl.
<br><B>standaloneStr</B> -    The value of the <code>standalone</code>
attribute of the XML decl.
<br><B>autoEncodingStr</B> -  The encoding string auto-detected by the
scanner. In absence of any 'encoding' attribute in the
XML decl, the XML standard specifies how a parser can
auto-detect. If there is no <code>encodingStr</code>
this is what will be used to try to decode the file.<br></DL><P></DL>
</DL>
<hr>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="SAXParser.html"> SAXParser </A><br>
<A HREF="DOMParser.html"> DOMParser </A><br>
</DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="80%">
	<TR>
		<TD WIDTH="100%" VALIGN="TOP">
			<P ALIGN="CENTER"><B>Xerces-C XML Parser for C++ Version 1.1</B><BR>
			Copyright &copy; 2000 The Apache Software Foundation. All Rights Reserved.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="100%">
			<P ALIGN="CENTER"><IMG SRC="ApacheLogo.jpg" WIDTH="387" HEIGHT="100" ALIGN="BOTTOM" BORDER="0">
		</TD>
	</TR>
</TABLE>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
