<html><head><TITLE>DOM_NodeList</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class   DOM_NodeList  </H2><BLOCKQUOTE>

The <code>NodeList</code> interface provides the abstraction of an ordered 
collection of nodes
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=35>
<param name=classes value="CDOM_NodeList,MDOM_NodeList.html">
<param name=before value="M">
<param name=after value="M">
<param name=indent value="0">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<TABLE>
<DT><h3>Public</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.28.3"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Comparison operators. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.28.3.1"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>operator == </B> (const <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A> &other) const <br>
<I>
Equality operator</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.3.2"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>operator == </B> (const DOM_NullPtr *nullPtr) const <br>
<I>
Use this comparison operator to test whether a Node List reference
is null</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.3.3"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>operator != </B> (const <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A> &other) const <br>
<I>
Inequality operator</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.3.4"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>operator != </B> (const DOM_NullPtr *nullPtr) const <br>
<I>
Use this comparison operator to test whether a Node List reference
is not null</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Constructors and assignment operator </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.28.1.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>DOM_NodeList</B> ()<br>
<I>
Default constructor for DOM_NodeList</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.1.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>DOM_NodeList</B> (const <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A> &other)<br>
<I>
Copy constructor</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.1.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A>& </TD><TD><B>operator = </B> (const <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A> &other)<br>
<I>
Assignment operator</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.1.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A>& </TD><TD><B>operator = </B> (const DOM_NullPtr *val)<br>
<I>
Assignment operator</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Destructor. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.28.2.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>~DOM_NodeList</B> ()<br>
<I>
Destructor for DOM_NodeList</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.4"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Get functions. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.28.4.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Node.html">DOM_Node</A> </TD><TD><B>item</B> (unsigned int index) const <br>
<I>
Returns the <code>index</code>th item in the collection</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.28.4.2"> <IMG BORDER=0 SRC=icon1.gif></A> unsigned  int </TD><TD><B>getLength</B> () const <br>
<I>
Returns the number of nodes in the list</I>
</TD></TR>
</TABLE>
</TD></TR></TABLE></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

The <code>NodeList</code> interface provides the abstraction of an ordered 
collection of nodes.  NodeLists are created by DOM_Document::getElementsByTagName(), 
DOM_Node::getChildNodes(), 

<p>The items in the <code>NodeList</code> are accessible via an integral 
index, starting from 0. 

NodeLists are "live", in that any changes to the document tree are immediately
reflected in any NodeLists that may have been created for that tree.

</BLOCKQUOTE>
<DL>

<A NAME="Constructors and assignment operator ">
<A NAME ="DOC.28.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Constructors and assignment operator </B></TT>
<DL></DL><P><DL>

<A NAME="DOM_NodeList">
<A NAME ="DOC.28.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DOM_NodeList()</B></TT>
<DD>
Default constructor for DOM_NodeList.  The resulting object does not
refer to an actual NodeList; it will compare == to 0, and is similar
to a null object reference variable in Java.  It may subsequently be
assigned to refer to an actual NodeList.

<DL></DL><P>
<A NAME="DOM_NodeList">
<A NAME ="DOC.28.1.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DOM_NodeList(const <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A> &other)</B></TT>
<DD>
Copy constructor.


<DL><DT><B>Parameters:</B><DD><B>other</B> -  The object to be copied.<br></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.28.1.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A>&  operator = (const <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A> &other)</B></TT>
<DD>
Assignment operator.


<DL><DT><B>Parameters:</B><DD><B>other</B> -  The object to be copied.<br></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.28.1.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A>&  operator = (const DOM_NullPtr *val)</B></TT>
<DD>
Assignment operator.  This overloaded variant is provided for
the sole purpose of setting a DOM_Node reference variable to
zero.  Nulling out a reference variable in this way will decrement
the reference count on the underlying Node object that the variable
formerly referenced.  This effect is normally obtained when reference
variable goes out of scope, but zeroing them can be useful for
global instances, or for local instances that will remain in scope
for an extended time,  when the storage belonging to the underlying
node needs to be reclaimed.


<DL><DT><B>Parameters:</B><DD><B>val.</B> -   Only a value of 0, or null, is allowed.<br></DL><P></DL>

<A NAME="Destructor. ">
<A NAME ="DOC.28.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Destructor. </B></TT>
<DL></DL><P><DL>

<A NAME="~DOM_NodeList">
<A NAME ="DOC.28.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  ~DOM_NodeList()</B></TT>
<DD>
Destructor for DOM_NodeList.  The object being destroyed is the reference
object, not the underlying NodeList node itself.

<p>Like most other DOM types in this implementation, memory management
of Node Lists is automatic.  Instances of DOM_NodeList function
as references to an underlying heap based implementation object,
and should never be explicitly new-ed or deleted in application code, but
should appear only as local variables or function parameters.
<DL></DL><P></DL>

<A NAME="Comparison operators. ">
<A NAME ="DOC.28.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Comparison operators. </B></TT>
<DL></DL><P><DL>

<A NAME="operator == ">
<A NAME ="DOC.28.3.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  operator == (const <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A> &other) const </B></TT>
<DD>
Equality operator.
Compares whether two node list
variables refer to the same underlying node list.  It does
not compare the contents of the node lists themselves.


<DL><DT><B>Returns:</B><DD>Returns true if node list refers to same underlying node list
<DT><B>Parameters:</B><DD><B>other</B> -  The value to be compared
<br></DL><P>
<A NAME="operator == ">
<A NAME ="DOC.28.3.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  operator == (const DOM_NullPtr *nullPtr) const </B></TT>
<DD>
Use this comparison operator to test whether a Node List reference
is null.


<DL><DT><B>Returns:</B><DD>Returns true if node list reference is null
<DT><B>Parameters:</B><DD><B>nullPtr</B> -  The value to be compared, which must be 0 or null.
<br></DL><P>
<A NAME="operator != ">
<A NAME ="DOC.28.3.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  operator != (const <!2><A HREF="DOM_NodeList.html#DOC.28.1.1">DOM_NodeList</A> &other) const </B></TT>
<DD>
Inequality operator.
Compares whether two node list
variables refer to the same underlying node list.  It does
not compare the contents of the node lists themselves.


<DL><DT><B>Returns:</B><DD>Returns true if node list refers to a different underlying node list
<DT><B>Parameters:</B><DD><B>other</B> -  The value to be compared
<br></DL><P>
<A NAME="operator != ">
<A NAME ="DOC.28.3.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  operator != (const DOM_NullPtr *nullPtr) const </B></TT>
<DD>
Use this comparison operator to test whether a Node List reference
is not null.


<DL><DT><B>Returns:</B><DD>Returns true if node list reference is not null
<DT><B>Parameters:</B><DD><B>nullPtr</B> -  The value to be compared, which must be 0 or null.
<br></DL><P></DL>

<A NAME="Get functions. ">
<A NAME ="DOC.28.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Get functions. </B></TT>
<DL></DL><P><DL>

<A NAME="item">
<A NAME ="DOC.28.4.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Node.html">DOM_Node</A>  item(unsigned int index) const </B></TT>
<DD>
Returns the <code>index</code>th item in the collection. 

If <code>index</code> is greater than or equal to the number of nodes in 
the list, this returns <code>null</code>.


<DL><DT><B>Returns:</B><DD>The node at the <code>index</code>th position in the 
<code>NodeList</code>, or <code>null</code> if that is not a valid 
index.
<DT><B>Parameters:</B><DD><B>index</B> -  Index into the collection.
<br></DL><P>
<A NAME="getLength">
<A NAME ="DOC.28.4.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> unsigned  int  getLength() const </B></TT>
<DD>
Returns the number of nodes in the list. 

The range of valid child node indices is 0 to <code>length-1</code> inclusive. 
<DL></DL><P></DL>
</DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="80%">
	<TR>
		<TD WIDTH="100%" VALIGN="TOP">
			<P ALIGN="CENTER"><B>Xerces-C XML Parser for C++ Version 1.1</B><BR>
			Copyright &copy; 2000 The Apache Software Foundation. All Rights Reserved.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="100%">
			<P ALIGN="CENTER"><IMG SRC="ApacheLogo.jpg" WIDTH="387" HEIGHT="100" ALIGN="BOTTOM" BORDER="0">
		</TD>
	</TR>
</TABLE>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
