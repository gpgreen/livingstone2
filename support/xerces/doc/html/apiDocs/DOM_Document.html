<html><head><TITLE>DOM_Document</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class   DOM_Document : public <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </H2><BLOCKQUOTE>

Class to refer to XML Document nodes in the DOM
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CDOM_Node,MDOM_Node.html,CDOM_Document,MDOM_Document.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<TABLE>
<DT><h3>Public</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.16.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Constructors and assignment operators </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.16.1.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>DOM_Document</B> ()<br>
<I>
The default constructor for DOM_Document creates a null
DOM_Document object that refers to no document</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.1.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>DOM_Document</B> (const <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A> &other)<br>
<I>
Copy constructor</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.1.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A>& </TD><TD><B>operator = </B> (const <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A> &other)<br>
<I>
Assignment operator

</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.1.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A>& </TD><TD><B>operator = </B> (const DOM_NullPtr *val)<br>
<I>
Assignment operator</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Destructor </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.16.2.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>~DOM_Document</B> ()<br>
<I>
Destructor</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Factory methods to create new nodes for the Document </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.16.3.1"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A> </TD><TD><B>createDocument</B> ()<br>
<I>
Create a new empty document</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Entity.html">DOM_Entity</A> </TD><TD><B>createEntity</B> (const <!1><A HREF="DOMString.html">DOMString</A> &name)<br>
<I>
Create a new entity</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Element.html">DOM_Element</A> </TD><TD><B>createElement</B> (const <!1><A HREF="DOMString.html">DOMString</A> &tagName)<br>
<I>
Creates an element of the type specified</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Element.html">DOM_Element</A> </TD><TD><B>createElement</B> (const XMLCh *tagName)<br>
<I>
Creates an element of the type specified</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_DocumentFragment.html">DOM_DocumentFragment</A> </TD><TD><B>createDocumentFragment</B> ()<br>
<I>
Creates an empty DocumentFragment object</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.6"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Text.html">DOM_Text</A> </TD><TD><B>createTextNode</B> (const <!1><A HREF="DOMString.html">DOMString</A> &data)<br>
<I>
Creates a Text node given the specified string</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.7"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Comment.html">DOM_Comment</A> </TD><TD><B>createComment</B> (const <!1><A HREF="DOMString.html">DOMString</A> &data)<br>
<I>
Creates a Comment node given the specified string</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.8"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_CDATASection.html">DOM_CDATASection</A> </TD><TD><B>createCDATASection</B> (const <!1><A HREF="DOMString.html">DOMString</A> &data)<br>
<I>
Creates a CDATASection node whose value  is the specified
string</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.9"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_DocumentType.html">DOM_DocumentType</A> </TD><TD><B>createDocumentType</B> (const <!1><A HREF="DOMString.html">DOMString</A> &name)<br>
<I>
Create a DocumentType node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.10"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Notation.html">DOM_Notation</A> </TD><TD><B>createNotation</B> (const <!1><A HREF="DOMString.html">DOMString</A> &name)<br>
<I>
Create a Notation</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.11"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_ProcessingInstruction.html">DOM_ProcessingInstruction</A> </TD><TD><B>createProcessingInstruction</B> (const <!1><A HREF="DOMString.html">DOMString</A> &target, const <!1><A HREF="DOMString.html">DOMString</A> &data)<br>
<I>
Creates a ProcessingInstruction node given the specified
name and data strings</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.12"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Attr.html">DOM_Attr</A> </TD><TD><B>createAttribute</B> (const <!1><A HREF="DOMString.html">DOMString</A> &name)<br>
<I>
Creates an Attr of the given name</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.13"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_EntityReference.html">DOM_EntityReference</A> </TD><TD><B>createEntityReference</B> (const <!1><A HREF="DOMString.html">DOMString</A> &name)<br>
<I>
Creates an EntityReference object</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.14"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_NodeIterator.html">DOM_NodeIterator</A> </TD><TD><B>createNodeIterator</B> (<!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> root, unsigned long whatToShow, <!1><A HREF="DOM_NodeFilter.html">DOM_NodeFilter</A>* filter, bool entityReferenceExpansion)<br>
<I>
Creates a NodeIterator object</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.3.15"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_TreeWalker.html">DOM_TreeWalker</A> </TD><TD><B>createTreeWalker</B> (<!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> root, unsigned long whatToShow, <!1><A HREF="DOM_NodeFilter.html">DOM_NodeFilter</A>* filter, bool entityReferenceExpansion)<br>
<I>
Creates a TreeWalker object</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.5"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Functions introduced in DOM Level 2. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.16.5.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>importNode</B> (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &importedNode, bool deep)<br>
<I>
Imports a node from another document to this document</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.5.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Element.html">DOM_Element</A> </TD><TD><B>createElementNS</B> (const <!1><A HREF="DOMString.html">DOMString</A> &namespaceURI, const <!1><A HREF="DOMString.html">DOMString</A> &qualifiedName)<br>
<I>
Creates an element of the given qualified name and 
namespace URI</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.5.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Attr.html">DOM_Attr</A> </TD><TD><B>createAttributeNS</B> (const <!1><A HREF="DOMString.html">DOMString</A> &namespaceURI, const <!1><A HREF="DOMString.html">DOMString</A> &qualifiedName)<br>
<I>
Creates an attribute of the given qualified name and namespace
URI</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.5.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_NodeList.html">DOM_NodeList</A> </TD><TD><B>getElementsByTagNameNS</B> (const <!1><A HREF="DOMString.html">DOMString</A> &namespaceURI, const <!1><A HREF="DOMString.html">DOMString</A> &localName) const <br>
<I>
Returns a <code>DOM_NodeList</code> of all the <code>DOM_Element</code>s
with a given <em>local name</em> and
namespace URI in the order in which they would be encountered in a
preorder traversal of the <code>DOM_Document</code> tree</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.5.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Element.html">DOM_Element</A> </TD><TD><B>getElementById</B> (const <!1><A HREF="DOMString.html">DOMString</A> &elementId)<br>
<I>
Returns the <code>DOM_Element</code> whose ID is given by <code>elementId</code></I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.4"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Getter functions </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.16.4.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_DocumentType.html">DOM_DocumentType</A> </TD><TD><B>getDoctype</B> () const <br>
<I>
Get Document Type Declaration (see <code>DOM_DocumentType</code>) associated
with  this document</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.4.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_DOMImplementation.html">DOM_DOMImplementation</A>& </TD><TD><B>getImplementation</B> () const <br>
<I>
Return the <code>DOMImplementation</code> object that handles this document</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.4.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Element.html">DOM_Element</A> </TD><TD><B>getDocumentElement</B> () const <br>
<I>
Return a reference to the root element of the document</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.16.4.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_NodeList.html">DOM_NodeList</A> </TD><TD><B>getElementsByTagName</B> (const <!1><A HREF="DOMString.html">DOMString</A> &tagname) const <br>
<I>
Returns a <code>DOM_NodeList</code> of all the elements with a
given tag name</I>
</TD></TR>
</TABLE>
</TD></TR></TABLE></DL>
<hr><H3>Inherited from <A HREF="DOM_Node.html">DOM_Node:</A></h3>

<DL>
<DL>
<DT><h3>Public</h3><DD><DT><P> <B>Cloning function. </B>

<DL>
<DT><A HREF="#DOC.25.5.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>cloneNode</B>(bool deep) const  </B>
 <DD><I>
Returns a duplicate of this node</I>

</DL>
<DT><P> <B>Destructor. </B>

<DL>
<DT><A HREF="#DOC.25.2.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>~DOM_Node</B>() </B>
 <DD><I>
Destructor for DOM_Node</I>

</DL>
<DT><P> <B>Equality and Inequality operators. </B>

<DL>
<DT><A HREF="#DOC.25.3.1"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>operator == </B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> & other) const  </B>
 <DD><I>
The equality operator</I>
<DT><A HREF="#DOC.25.3.2"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>operator == </B>(const DOM_NullPtr *other) const  </B>
 <DD><I>
Compare with a pointer</I>
<DT><A HREF="#DOC.25.3.3"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>operator != </B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> & other) const  </B>
 <DD><I>
The inequality operator</I>
<DT><A HREF="#DOC.25.3.4"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>operator != </B>(const DOM_NullPtr * other) const  </B>
 <DD><I>
Compare with a pointer</I>

</DL>
<DT><P> <B>Functions to modify the DOM Node. </B>

<DL>
<DT><A HREF="#DOC.25.6.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>insertBefore</B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild, const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &refChild) </B>
 <DD><I>
Inserts the node <code>newChild</code> before the existing child node
<code>refChild</code></I>
<DT><A HREF="#DOC.25.6.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>replaceChild</B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild, const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &oldChild) </B>
 <DD><I>
Replaces the child node <code>oldChild</code> with <code>newChild</code>
in the list of children, and returns the <code>oldChild</code> node</I>
<DT><A HREF="#DOC.25.6.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>removeChild</B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &oldChild) </B>
 <DD><I>
Removes the child node indicated by <code>oldChild</code> from the list
of children, and returns it</I>
<DT><A HREF="#DOC.25.6.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>appendChild</B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild) </B>
 <DD><I>
Adds the node <code>newChild</code> to the end of the list of children of
this node</I>

</DL>
<DT><P> <B>Get functions. </B>

<DL>
<DT><A HREF="#DOC.25.4.10"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A>  <B>getNodeName</B>() const  </B>
 <DD><I>
The name of this node, depending on its type; see the table above</I>
<DT><A HREF="#DOC.25.4.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A>  <B>getNodeValue</B>() const  </B>
 <DD><I>
Gets the value of this node, depending on its type</I>
<DT><A HREF="#DOC.25.4.11"> <IMG BORDER=0 SRC=icon1.gif></A> short  <B>getNodeType</B>() const  </B>
 <DD><I>
An enum value representing the type of the underlying object</I>
<DT><A HREF="#DOC.25.4.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getParentNode</B>() const  </B>
 <DD><I>
Gets the parent of this node</I>
<DT><A HREF="#DOC.25.4.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_NodeList.html">DOM_NodeList</A>  <B>getChildNodes</B>() const  </B>
 <DD><I>
Gets a <code>NodeList</code> that contains all children of this node</I>
<DT><A HREF="#DOC.25.4.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getFirstChild</B>() const  </B>
 <DD><I>
Gets the first child of this node</I>
<DT><A HREF="#DOC.25.4.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getLastChild</B>() const  </B>
 <DD><I>
Gets the last child of this node</I>
<DT><A HREF="#DOC.25.4.6"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getPreviousSibling</B>() const  </B>
 <DD><I>
Gets the node immediately preceding this node</I>
<DT><A HREF="#DOC.25.4.7"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getNextSibling</B>() const  </B>
 <DD><I>
Gets the node immediately following this node</I>
<DT><A HREF="#DOC.25.4.12"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_NamedNodeMap.html">DOM_NamedNodeMap</A>  <B>getAttributes</B>() const  </B>
 <DD><I>
Gets a <code>NamedNodeMap</code> containing the attributes of this node (if it
is an <code>Element</code>) or <code>null</code> otherwise</I>
<DT><A HREF="#DOC.25.4.8"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Document.html">DOM_Document</A>  <B>getOwnerDocument</B>() const  </B>
 <DD><I>
Gets the <code>DOM_Document</code> object associated with this node</I>
<DT><A HREF="#DOC.25.4.9"> <IMG BORDER=0 SRC=icon1.gif></A> void*  <B>getUserData</B>() const  </B>
 <DD><I>
Return the user data pointer</I>

</DL>
<DT><P> <B>Query functions. </B>

<DL>
<DT><A HREF="#DOC.25.7.1"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>hasChildNodes</B>() const  </B>
 <DD><I>
This is a convenience method to allow easy determination of whether a
node has any children</I>
<DT><A HREF="#DOC.25.7.2"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>isNull</B>() const  </B>
 <DD><I>
Test whether this node is null</I>

</DL>
<DT><P> <B>Set functions. </B>

<DL>
<DT><A HREF="#DOC.25.8.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setNodeValue</B>(const <!1><A HREF="DOMString.html">DOMString</A> &nodeValue) </B>
 <DD><I>
Sets the value of the node</I>
<DT><A HREF="#DOC.25.8.2"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setUserData</B>(void *p) </B>
 <DD><I>
Set the user data for a node</I>

</DL>
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Class to refer to XML Document nodes in the DOM.

Conceptually, a DOM document node is the root of the document tree, and provides
the  primary access to the document's data.
<p>Since elements, text nodes, comments, processing instructions, etc.
cannot exist outside the context of a <code>Document</code>, the
<code>Document</code> interface also contains the factory methods needed
to create these objects.  The <code>Node</code> objects created have a
<code>ownerDocument</code> attribute which associates them with the
<code>Document</code> within whose  context they were created.

</BLOCKQUOTE>
<DL>

<A NAME="Constructors and assignment operators ">
<A NAME ="DOC.16.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Constructors and assignment operators </B></TT>
<DL></DL><P><DL>

<A NAME="DOM_Document">
<A NAME ="DOC.16.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DOM_Document()</B></TT>
<DD>
The default constructor for DOM_Document creates a null
DOM_Document object that refers to no document.  It may subsequently be
assigned to refer to an actual Document node.

To create a new document, use the static method
<code> DOM_Document::createDocument(). </code>

<DL></DL><P>
<A NAME="DOM_Document">
<A NAME ="DOC.16.1.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DOM_Document(const <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A> &other)</B></TT>
<DD>
Copy constructor.  Creates a new <code>DOM_Document</code> that refers to the
same underlying actual document as the original.


<DL><DT><B>Parameters:</B><DD><B>other</B> -  The object to be copied<br></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.16.1.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A>&  operator = (const <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A> &other)</B></TT>
<DD>
Assignment operator


<DL><DT><B>Parameters:</B><DD><B>other</B> -  The object to be copied<br></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.16.1.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A>&  operator = (const DOM_NullPtr *val)</B></TT>
<DD>
Assignment operator.  This overloaded variant is provided for
the sole purpose of setting a DOM_Node reference variable to
zero.  Nulling out a reference variable in this way will decrement
the reference count on the underlying Node object that the variable
formerly referenced.  This effect is normally obtained when reference
variable goes out of scope, but zeroing them can be useful for
global instances, or for local instances that will remain in scope
for an extended time,  when the storage belonging to the underlying
node needs to be reclaimed.


<DL><DT><B>Parameters:</B><DD><B>val.</B> -   Only a value of 0, or null, is allowed.<br></DL><P></DL>

<A NAME="Destructor ">
<A NAME ="DOC.16.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Destructor </B></TT>
<DL></DL><P><DL>

<A NAME="~DOM_Document">
<A NAME ="DOC.16.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  ~DOM_Document()</B></TT>
<DD>
Destructor.  The object being destroyed is the reference
object, not the underlying Document itself.

<p>The reference counting memory management will
delete the underlying document itself if this
DOM_Document is the last remaining to refer to the Document,
and if there are no remaining references to any of the nodes
within the document tree.  If other live references do remain,
the underlying document itself remains also.

<DL></DL><P></DL>

<A NAME="Factory methods to create new nodes for the Document ">
<A NAME ="DOC.16.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Factory methods to create new nodes for the Document </B></TT>
<DL></DL><P><DL>

<A NAME="createDocument">
<A NAME ="DOC.16.3.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="DOM_Document.html#DOC.16.1.1">DOM_Document</A>  createDocument()</B></TT>
<DD>
Create a new empty document.

This differs from the <code> DOM_Document </code> default
constructor, which creates
a null reference only, not an actual document.

<p>This function is an extension to the DOM API, which
lacks any mechanism for the creation of new documents.

<DL><DT><B>Returns:</B><DD>A new <code>DOM_Document</code>, which may then
be populated using the DOM API calls.
</DL><P>
<A NAME="createEntity">
<A NAME ="DOC.16.3.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Entity.html">DOM_Entity</A>  createEntity(const <!1><A HREF="DOMString.html">DOMString</A> &name)</B></TT>
<DD>
Create a new entity.

Non-standard extension.

<DL><DT><B>Parameters:</B><DD><B>name</B> -  The name of the entity to instantiate
<br></DL><P>
<A NAME="createElement">
<A NAME ="DOC.16.3.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Element.html">DOM_Element</A>  createElement(const <!1><A HREF="DOMString.html">DOMString</A> &tagName)</B></TT>
<DD>
Creates an element of the type specified.

Note that the instance returned
implements the Element interface, so attributes can be specified
directly  on the returned object.

<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
INVALID_CHARACTER_ERR: Raised if the specified name contains an
illegal character.<br><DT><B>Returns:</B><DD>A <code>DOM_Element</code> that reference the new element.

<DT><B>Parameters:</B><DD><B>tagName</B> -  The name of the element type to instantiate.
<br></DL><P>
<A NAME="createElement">
<A NAME ="DOC.16.3.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Element.html">DOM_Element</A>  createElement(const XMLCh *tagName)</B></TT>
<DD>
Creates an element of the type specified.
This non-standard overload of createElement, with the name specified as
raw Unicode string, is intended for use from XML parsers,
and is the best performing way to create elements.  The name
string is not checked for conformance to the XML rules for valid
element names.



<DL><DT><B>Returns:</B><DD>A new <CODE>DOM_Element</CODE> 
object with the <CODE>nodeName</CODE> attribute set to 
<CODE>tagName</CODE>, and <CODE>localName</CODE>, 
<CODE>prefix</CODE>, and <CODE>namespaceURI</CODE> set to 
<CODE>null</CODE>.
<DT><B>Parameters:</B><DD><B>tagName</B> -  The name of the element type to instantiate, as
a null-terminated unicode string.
<br></DL><P>
<A NAME="createDocumentFragment">
<A NAME ="DOC.16.3.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_DocumentFragment.html">DOM_DocumentFragment</A>  createDocumentFragment()</B></TT>
<DD>
Creates an empty DocumentFragment object.


<DL><DT><B>Returns:</B><DD>A <code>DOM_DocumentFragment</code> that references the newly
created document fragment.
</DL><P>
<A NAME="createTextNode">
<A NAME ="DOC.16.3.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Text.html">DOM_Text</A>  createTextNode(const <!1><A HREF="DOMString.html">DOMString</A> &data)</B></TT>
<DD>
Creates a Text node given the specified string.


<DL><DT><B>Returns:</B><DD>A <code>DOM_Text</code> object that references the newly
created text node.
<DT><B>Parameters:</B><DD><B>data</B> -  The data for the node.
<br></DL><P>
<A NAME="createComment">
<A NAME ="DOC.16.3.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Comment.html">DOM_Comment</A>  createComment(const <!1><A HREF="DOMString.html">DOMString</A> &data)</B></TT>
<DD>
Creates a Comment node given the specified string.


<DL><DT><B>Returns:</B><DD>A <code>DOM_Comment</code> that references the newly
created comment node.
<DT><B>Parameters:</B><DD><B>data</B> -  The data for the comment.
<br></DL><P>
<A NAME="createCDATASection">
<A NAME ="DOC.16.3.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_CDATASection.html">DOM_CDATASection</A>  createCDATASection(const <!1><A HREF="DOMString.html">DOMString</A> &data)</B></TT>
<DD>
Creates a CDATASection node whose value  is the specified
string.


<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
NOT_SUPPORTED_ERR: Raised if this document is an HTML document.<br><DT><B>Returns:</B><DD>A <code>DOM_CDATASection</code> object.

<DT><B>Parameters:</B><DD><B>data</B> -  The data for the <code>DOM_CDATASection</code> contents.
<br></DL><P>
<A NAME="createDocumentType">
<A NAME ="DOC.16.3.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_DocumentType.html">DOM_DocumentType</A>  createDocumentType(const <!1><A HREF="DOMString.html">DOMString</A> &name)</B></TT>
<DD>
Create a DocumentType node.  Non-standard extension.


<DL><DT><B>Returns:</B><DD>A <code>DOM_DocumentType</code> that references the newly
created DocumentType node.

</DL><P>
<A NAME="createNotation">
<A NAME ="DOC.16.3.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Notation.html">DOM_Notation</A>  createNotation(const <!1><A HREF="DOMString.html">DOMString</A> &name)</B></TT>
<DD>
Create a Notation.

Non-standard extension.


<DL><DT><B>Returns:</B><DD>A <code>DOM_Notation</code> that references the newly
created Notation node.
<DT><B>Parameters:</B><DD><B>name</B> -  The name of the notation to instantiate
<br></DL><P>
<A NAME="createProcessingInstruction">
<A NAME ="DOC.16.3.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_ProcessingInstruction.html">DOM_ProcessingInstruction</A>  createProcessingInstruction(const <!1><A HREF="DOMString.html">DOMString</A> &target, const <!1><A HREF="DOMString.html">DOMString</A> &data)</B></TT>
<DD>
Creates a ProcessingInstruction node given the specified
name and data strings.


<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
INVALID_CHARACTER_ERR: Raised if an illegal character is specified.<br><DT><B>Returns:</B><DD>A <code>DOM_ProcessingInstruction</code> that references the newly
created PI node.

<DT><B>Parameters:</B><DD><B>target</B> -  The target part of the processing instruction.
<br><B>data</B> -  The data for the node.
<br></DL><P>
<A NAME="createAttribute">
<A NAME ="DOC.16.3.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Attr.html">DOM_Attr</A>  createAttribute(const <!1><A HREF="DOMString.html">DOMString</A> &name)</B></TT>
<DD>
Creates an Attr of the given name.

Note that the
<code>Attr</code> instance can then be attached to an Element
using the <code>DOMElement::setAttribute()</code> method.

<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
INVALID_CHARACTER_ERR: Raised if the specified name contains an
illegal character.<br><DT><B>Returns:</B><DD>A new <CODE>DOM_Attr</CODE> 
object with the <CODE>nodeName</CODE> attribute set to 
<CODE>name</CODE>, and <CODE>localName</CODE>, <CODE>prefix</CODE>, 
and <CODE>namespaceURI</CODE> set to 
<CODE>null</CODE>.

<DT><B>Parameters:</B><DD><B>name</B> -  The name of the attribute.
<br></DL><P>
<A NAME="createEntityReference">
<A NAME ="DOC.16.3.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_EntityReference.html">DOM_EntityReference</A>  createEntityReference(const <!1><A HREF="DOMString.html">DOMString</A> &name)</B></TT>
<DD>
Creates an EntityReference object.


<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
INVALID_CHARACTER_ERR: Raised if the specified name contains an
illegal character.<br><DT><B>Returns:</B><DD>A <code>DOM_EntityReference</code> that references the newly
created EntityReference node.

<DT><B>Parameters:</B><DD><B>name</B> -  The name of the entity to reference.
<br></DL><P>
<A NAME="createNodeIterator">
<A NAME ="DOC.16.3.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_NodeIterator.html">DOM_NodeIterator</A>  createNodeIterator(<!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> root, unsigned long whatToShow, <!1><A HREF="DOM_NodeFilter.html">DOM_NodeFilter</A>* filter, bool entityReferenceExpansion)</B></TT>
<DD>
Creates a NodeIterator object.   (DOM2)

NodeIterators are used to step through a set of nodes, e.g. the set of nodes in a NodeList, the
document subtree governed by a particular node, the results of a query, or any other set of nodes.
The set of nodes to be iterated is determined by the implementation of the NodeIterator. DOM Level 2
specifies a single NodeIterator implementation for document-order traversal of a document subtree.
Instances of these iterators are created by calling <code>DocumentTraversal.createNodeIterator()</code>. 

To produce a view of the document that has entity references expanded and does not
expose the entity reference node itself, use the <code>whatToShow</code> flags to hide the entity
reference node and set expandEntityReferences to true when creating the iterator. To
produce a view of the document that has entity reference nodes but no entity expansion,
use the <code>whatToShow</code> flags to show the entity reference node and set
expandEntityReferences to false.

<p><b>"Experimental - subject to change"</b></p>


<DL><DT><B>Parameters:</B><DD><B>root</B> -  The root node of the DOM tree
<br><B>whatToShow</B> -  This attribute determines which node types are presented via the iterator.
<br><B>filter</B> -  The filter used to screen nodes
<br><B>entityReferenceExpansion</B> -  The value of this flag determines whether the children of entity reference nodes are
visible to the iterator. If false, they will be skipped over.<br></DL><P>
<A NAME="createTreeWalker">
<A NAME ="DOC.16.3.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_TreeWalker.html">DOM_TreeWalker</A>  createTreeWalker(<!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> root, unsigned long whatToShow, <!1><A HREF="DOM_NodeFilter.html">DOM_NodeFilter</A>* filter, bool entityReferenceExpansion)</B></TT>
<DD>
Creates a TreeWalker object.   (DOM2)

TreeWalker objects are used to navigate a document tree or subtree using the view of the document defined
by its whatToShow flags and any filters that are defined for the TreeWalker. Any function which performs
navigation using a TreeWalker will automatically support any view defined by a TreeWalker.

Omitting nodes from the logical view of a subtree can result in a structure that is substantially different from
the same subtree in the complete, unfiltered document. Nodes that are siblings in the TreeWalker view may
be children of different, widely separated nodes in the original view. For instance, consider a Filter that skips
all nodes except for Text nodes and the root node of a document. In the logical view that results, all text
nodes will be siblings and appear as direct children of the root node, no matter how deeply nested the
structure of the original document.

To produce a view of the document that has entity references expanded
and does not expose the entity reference node itself, use the whatToShow
flags to hide the entity reference node and set <code>expandEntityReferences</code> to
true when creating the TreeWalker. To produce a view of the document
that has entity reference nodes but no entity expansion, use the
<code>whatToShow</code> flags to show the entity reference node and set
<code>expandEntityReferences</code> to false

<p><b>"Experimental - subject to change"</b></p>


<DL><DT><B>Parameters:</B><DD><B>root</B> -  The root node of the DOM tree
<br><B>whatToShow</B> -  This attribute determines which node types are presented via the tree-walker.
<br><B>filter</B> -  The filter used to screen nodes
<br><B>entityReferenceExpansion</B> -  The value of this flag determines whether the children of entity reference nodes are
visible to the tree-walker. If false, they will be skipped over.<br></DL><P></DL>

<A NAME="Getter functions ">
<A NAME ="DOC.16.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Getter functions </B></TT>
<DL></DL><P><DL>

<A NAME="getDoctype">
<A NAME ="DOC.16.4.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_DocumentType.html">DOM_DocumentType</A>  getDoctype() const </B></TT>
<DD>
Get Document Type Declaration (see <code>DOM_DocumentType</code>) associated
with  this document.

For documents without
a document type declaration this returns <code>null</code> reference object. The DOM Level
1 does not support editing the Document Type Declaration, therefore
<code>docType</code> cannot be altered in any way.
<DL></DL><P>
<A NAME="getImplementation">
<A NAME ="DOC.16.4.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_DOMImplementation.html">DOM_DOMImplementation</A>&  getImplementation() const </B></TT>
<DD>
Return the <code>DOMImplementation</code> object that handles this document
<DL></DL><P>
<A NAME="getDocumentElement">
<A NAME ="DOC.16.4.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Element.html">DOM_Element</A>  getDocumentElement() const </B></TT>
<DD>
Return a reference to the root element of the document
<DL></DL><P>
<A NAME="getElementsByTagName">
<A NAME ="DOC.16.4.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_NodeList.html">DOM_NodeList</A>  getElementsByTagName(const <!1><A HREF="DOMString.html">DOMString</A> &tagname) const </B></TT>
<DD>
Returns a <code>DOM_NodeList</code> of all the elements with a
given tag name.  The returned node list is "live", in that changes
to the document tree made after a nodelist was initially
returned will be immediately reflected in the node list.

The elements in the node list are ordered in the same order in which they
would be encountered in a
preorder traversal of the <code>Document</code> tree.

<DL><DT><B>Returns:</B><DD>A reference to a NodeList containing all the matched
<code>Element</code>s.
<DT><B>Parameters:</B><DD><B>tagname</B> -  The name of the tag to match on. The special value "*"
matches all tags.
<br></DL><P></DL>

<A NAME="Functions introduced in DOM Level 2. ">
<A NAME ="DOC.16.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Functions introduced in DOM Level 2. </B></TT>
<DL></DL><P><DL>

<A NAME="importNode">
<A NAME ="DOC.16.5.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  importNode(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &importedNode, bool deep)</B></TT>
<DD>
Imports a node from another document to this document. 
The returned node has no parent (<CODE>parentNode</CODE> is 
<CODE>null</CODE>). The source node is not altered or removed from the 
original document; this method creates a new copy of the source 
node.<BR>For all nodes, importing a node creates a node object owned by 
the importing document, with attribute values identical to the source 
node's <CODE>nodeName</CODE> and <CODE>nodeType</CODE>, plus the 
attributes related to namespaces (prefix and namespaces URI).

<p><b>"Experimental - subject to change"</b></p>


<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
NOT_SUPPORTED_ERR: Raised if the type of node being imported is 
not supported.<br><DT><B>Returns:</B><DD>The imported node that belongs to this <CODE>DOM_Document</CODE>.

<DT><B>Parameters:</B><DD><B>importedNode</B> -  The node to import.
<br><B>deep</B> -  If <CODE>true</CODE>, recursively import the subtree under the 
specified node; if <CODE>false</CODE>, import only the node itself, 
as explained above. This does not apply to <CODE>DOM_Attr</CODE>, 
<CODE>DOM_EntityReference</CODE>, and <CODE>DOM_Notation</CODE> nodes.
<br></DL><P>
<A NAME="createElementNS">
<A NAME ="DOC.16.5.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Element.html">DOM_Element</A>  createElementNS(const <!1><A HREF="DOMString.html">DOMString</A> &namespaceURI, const <!1><A HREF="DOMString.html">DOMString</A> &qualifiedName)</B></TT>
<DD>
Creates an element of the given qualified name and 
namespace URI.

<p><b>"Experimental - subject to change"</b></p>


<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
INVALID_CHARACTER_ERR: Raised if the specified qualified name contains
an illegal character.
<br>
NAMESPACE_ERR: Raised if the <CODE>qualifiedName</CODE> is 
malformed, if the <CODE>qualifiedName</CODE> has a prefix and the 
<CODE>namespaceURI</CODE> is <CODE>null</CODE> or an empty string, 
or if the <CODE>qualifiedName</CODE> has a prefix that is "xml" and 
the <CODE>namespaceURI</CODE> is different from 
"http:     <br><DT><B>Returns:</B><DD>A new <code>DOM_Element</code> object.

<DT><B>Parameters:</B><DD><B>namespaceURI</B> -  The <em>namespace URI</em> of
the element to create.
<br><B>qualifiedName</B> -  The <em>qualified name</em>
of the element type to instantiate.
<br></DL><P>
<A NAME="createAttributeNS">
<A NAME ="DOC.16.5.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Attr.html">DOM_Attr</A>  createAttributeNS(const <!1><A HREF="DOMString.html">DOMString</A> &namespaceURI, const <!1><A HREF="DOMString.html">DOMString</A> &qualifiedName)</B></TT>
<DD>
Creates an attribute of the given qualified name and namespace
URI.

<p><b>"Experimental - subject to change"</b></p>


<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
INVALID_CHARACTER_ERR: Raised if the specified qualified name contains
an illegal character.
<br>
NAMESPACE_ERR: Raised if the <CODE>qualifiedName</CODE> is 
malformed, if the <CODE>qualifiedName</CODE> has a prefix and the 
<CODE>namespaceURI</CODE> is <CODE>null</CODE> or an empty string, 
if the <CODE>qualifiedName</CODE> has a prefix that is "xml" and the 
<CODE>namespaceURI</CODE> is different from 
"http:     *      <CODE>qualifiedName</CODE> has a prefix that is "xmlns" and the 
<CODE>namespaceURI</CODE> is different from 
"http:     *      <CODE>qualifiedName</CODE> is "xmlns" and the 
<CODE>namespaceURI</CODE> is different from 
"http:     <br><DT><B>Returns:</B><DD>A new <code>DOM_Attr</code> object.

<DT><B>Parameters:</B><DD><B>namespaceURI</B> -  The <em>namespace URI</em> of
the attribute to create.
<br><B>qualifiedName</B> -  The <em>qualified name</em>
of the attribute to instantiate.
<br></DL><P>
<A NAME="getElementsByTagNameNS">
<A NAME ="DOC.16.5.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_NodeList.html">DOM_NodeList</A>  getElementsByTagNameNS(const <!1><A HREF="DOMString.html">DOMString</A> &namespaceURI, const <!1><A HREF="DOMString.html">DOMString</A> &localName) const </B></TT>
<DD>
Returns a <code>DOM_NodeList</code> of all the <code>DOM_Element</code>s
with a given <em>local name</em> and
namespace URI in the order in which they would be encountered in a
preorder traversal of the <code>DOM_Document</code> tree.

<p><b>"Experimental - subject to change"</b></p>


<DL><DT><B>Returns:</B><DD>A new <code>DOM_NodeList</code> object containing all the matched
<code>DOM_Element</code>s.
<DT><B>Parameters:</B><DD><B>namespaceURI</B> -  The <em>namespace URI</em> of
the elements to match on. The special value "*" matches all
namespaces.
<br><B>localName</B> -  The <em>local name</em> of the
elements to match on. The special value "*" matches all local names.
<br></DL><P>
<A NAME="getElementById">
<A NAME ="DOC.16.5.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Element.html">DOM_Element</A>  getElementById(const <!1><A HREF="DOMString.html">DOMString</A> &elementId)</B></TT>
<DD>
Returns the <code>DOM_Element</code> whose ID is given by <code>elementId</code>.
If no such element exists, returns <code>null</code>.
Behavior is not defined if more than one element has this <code>ID</code>.
<P><B>Note:</B> The DOM implementation must have information that says 
which attributes are of type ID. Attributes with the name "ID" are not of 
type ID unless so defined. Implementations that do not know whether 
attributes are of type ID or not are expected to return 
<CODE>null</CODE>.</P>

<p><b>"Experimental - subject to change"</b></p>


<DL><DT><B>Returns:</B><DD>The matching element.
<DT><B>Parameters:</B><DD><B>elementId</B> -  The unique <code>id</code> value for an element.
<br></DL><P></DL>
</DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="80%">
	<TR>
		<TD WIDTH="100%" VALIGN="TOP">
			<P ALIGN="CENTER"><B>Xerces-C XML Parser for C++ Version 1.1</B><BR>
			Copyright &copy; 2000 The Apache Software Foundation. All Rights Reserved.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="100%">
			<P ALIGN="CENTER"><IMG SRC="ApacheLogo.jpg" WIDTH="387" HEIGHT="100" ALIGN="BOTTOM" BORDER="0">
		</TD>
	</TR>
</TABLE>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
