<html><head><TITLE>DOM_Node</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class   DOM_Node  </H2><BLOCKQUOTE>

The <code>Node</code> interface is the primary datatype for the entire
Document Object Model
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=335>
<param name=classes value="CDOM_Node,MDOM_Node.html,CDOM_ProcessingInstruction,MDOM_ProcessingInstruction.html,CDOM_Notation,MDOM_Notation.html,CDOM_EntityReference,MDOM_EntityReference.html,CDOM_Entity,MDOM_Entity.html,CDOM_Element,MDOM_Element.html,CDOM_DocumentType,MDOM_DocumentType.html,CDOM_DocumentFragment,MDOM_DocumentFragment.html,CDOM_Document,MDOM_Document.html,CDOM_CharacterData,MDOM_CharacterData.html,CDOM_Attr,MDOM_Attr.html">
<param name=before value="M,M|_,MR_,MR_,MR_,MR_,MR_,MR_,MR_,MR_,Mr_">
<param name=after value="M,M,M,M,M,M,M,M,M,M,M">
<param name=indent value="0,0,0,0,0,0,0,0,0,0,0">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<TABLE>
<DT><h3>Public</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.25.5"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Cloning function. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.25.5.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>cloneNode</B> (bool deep) const <br>
<I>
Returns a duplicate of this node</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Constructors and assignment operators </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.25.1.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>DOM_Node</B> ()<br>
<I>
Default constructor for DOM_Node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.1.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>DOM_Node</B> (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &other)<br>
<I>
Copy constructor</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.1.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>& </TD><TD><B>operator = </B> (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &other)<br>
<I>
Assignment operator</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.1.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>& </TD><TD><B>operator = </B> (const DOM_NullPtr *val)<br>
<I>
Assignment operator</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Destructor. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.25.2.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>~DOM_Node</B> ()<br>
<I>
Destructor for DOM_Node</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.3"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Equality and Inequality operators. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.25.3.1"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>operator == </B> (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> & other) const <br>
<I>
The equality operator</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.3.2"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>operator == </B> (const DOM_NullPtr *other) const <br>
<I>
Compare with a pointer</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.3.3"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>operator != </B> (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> & other) const <br>
<I>
The inequality operator</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.3.4"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>operator != </B> (const DOM_NullPtr * other) const <br>
<I>
Compare with a pointer</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.9"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Functions introduced in DOM Level 2. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.25.9.1"> <IMG BORDER=0 SRC=icon1.gif></A> void </TD><TD><B>normalize</B> ()<br>
<I>
Puts all <CODE>DOM_Text</CODE> 
nodes in the full depth of the sub-tree underneath this <CODE>DOM_Node</CODE>, 
including attribute nodes, into a "normal" form where only markup (e</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.9.2"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>supports</B> (const <!1><A HREF="DOMString.html">DOMString</A> &feature, const <!1><A HREF="DOMString.html">DOMString</A> &version) const <br>
<I>
Tests whether the DOM implementation implements a specific
feature and that feature is supported by this node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.9.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A> </TD><TD><B>getNamespaceURI</B> () const <br>
<I>
Get the <em>namespace URI</em> of
this node, or <code>null</code> if it is unspecified</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.9.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A> </TD><TD><B>getPrefix</B> () const <br>
<I>
Get the <em>namespace prefix</em>
of this node, or <code>null</code> if it is unspecified</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.9.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A> </TD><TD><B>getLocalName</B> () const <br>
<I>
Returns the local part of the <em>qualified name</em> of this node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.9.6"> <IMG BORDER=0 SRC=icon1.gif></A> void </TD><TD><B>setPrefix</B> (const <!1><A HREF="DOMString.html">DOMString</A> &prefix)<br>
<I>
Set the <em>namespace prefix</em> of this node</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.6"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Functions to modify the DOM Node. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.25.6.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>insertBefore</B> (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild, const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &refChild)<br>
<I>
Inserts the node <code>newChild</code> before the existing child node
<code>refChild</code></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.6.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>replaceChild</B> (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild, const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &oldChild)<br>
<I>
Replaces the child node <code>oldChild</code> with <code>newChild</code>
in the list of children, and returns the <code>oldChild</code> node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.6.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>removeChild</B> (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &oldChild)<br>
<I>
Removes the child node indicated by <code>oldChild</code> from the list
of children, and returns it</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.6.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>appendChild</B> (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild)<br>
<I>
Adds the node <code>newChild</code> to the end of the list of children of
this node</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Get functions. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.25.4.10"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A> </TD><TD><B>getNodeName</B> () const <br>
<I>
The name of this node, depending on its type; see the table above</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A> </TD><TD><B>getNodeValue</B> () const <br>
<I>
Gets the value of this node, depending on its type</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.11"> <IMG BORDER=0 SRC=icon1.gif></A> short </TD><TD><B>getNodeType</B> () const <br>
<I>
An enum value representing the type of the underlying object</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>getParentNode</B> () const <br>
<I>
Gets the parent of this node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_NodeList.html">DOM_NodeList</A> </TD><TD><B>getChildNodes</B> () const <br>
<I>
Gets a <code>NodeList</code> that contains all children of this node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>getFirstChild</B> () const <br>
<I>
Gets the first child of this node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>getLastChild</B> () const <br>
<I>
Gets the last child of this node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.6"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>getPreviousSibling</B> () const <br>
<I>
Gets the node immediately preceding this node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.7"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </TD><TD><B>getNextSibling</B> () const <br>
<I>
Gets the node immediately following this node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.12"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_NamedNodeMap.html">DOM_NamedNodeMap</A> </TD><TD><B>getAttributes</B> () const <br>
<I>
Gets a <code>NamedNodeMap</code> containing the attributes of this node (if it
is an <code>Element</code>) or <code>null</code> otherwise</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.8"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Document.html">DOM_Document</A> </TD><TD><B>getOwnerDocument</B> () const <br>
<I>
Gets the <code>DOM_Document</code> object associated with this node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.4.9"> <IMG BORDER=0 SRC=icon1.gif></A> void* </TD><TD><B>getUserData</B> () const <br>
<I>
Return the user data pointer</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.7"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Query functions. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.25.7.1"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>hasChildNodes</B> () const <br>
<I>
This is a convenience method to allow easy determination of whether a
node has any children</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.7.2"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>isNull</B> () const <br>
<I>
Test whether this node is null</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.8"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Set functions. </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.25.8.1"> <IMG BORDER=0 SRC=icon1.gif></A> void </TD><TD><B>setNodeValue</B> (const <!1><A HREF="DOMString.html">DOMString</A> &nodeValue)<br>
<I>
Sets the value of the node</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.25.8.2"> <IMG BORDER=0 SRC=icon1.gif></A> void </TD><TD><B>setUserData</B> (void *p)<br>
<I>
Set the user data for a node</I>
</TD></TR>
</TABLE>
</TD></TR></TABLE></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

The <code>Node</code> interface is the primary datatype for the entire
Document Object Model.

It represents a single node in the document tree.
While all objects implementing the <code>Node</code> interface expose
methods for dealing with children, not all objects implementing the
<code>Node</code> interface may have children. For example,
<code>Text</code> nodes may not have children, and adding children to such
nodes results in a <code>DOMException</code> being raised.
<p>The attributes <code>nodeName</code>, <code>nodeValue</code>  and
<code>attributes</code> are  included as a mechanism to get at node
information without  casting down to the specific derived interface. In
cases where  there is no obvious mapping of these attributes for a specific
<code>nodeType</code> (e.g., <code>nodeValue</code> for an Element  or
<code>attributes</code>  for a Comment), this returns <code>null</code>.
Note that the  specialized interfaces may contain additional and more
convenient mechanisms to get and set the relevant information.

</BLOCKQUOTE>
<DL>

<A NAME="Constructors and assignment operators ">
<A NAME ="DOC.25.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Constructors and assignment operators </B></TT>
<DL></DL><P><DL>

<A NAME="DOM_Node">
<A NAME ="DOC.25.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DOM_Node()</B></TT>
<DD>
Default constructor for DOM_Node.  The resulting object does not
refer to an actual  node; it will compare == to 0, and is similar
to a null object reference variable in Java.  It may subsequently be
assigned to refer to an actual node.  "Acutal Nodes" will always
be of some derived type, such as Element or Attr.

<DL></DL><P>
<A NAME="DOM_Node">
<A NAME ="DOC.25.1.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DOM_Node(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &other)</B></TT>
<DD>
Copy constructor.


<DL><DT><B>Parameters:</B><DD><B>other</B> -  The object to be copied.<br></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.25.1.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>&  operator = (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &other)</B></TT>
<DD>
Assignment operator.


<DL><DT><B>Parameters:</B><DD><B>other</B> -  The source to be assigned.<br></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.25.1.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>&  operator = (const DOM_NullPtr *val)</B></TT>
<DD>
Assignment operator.  This overloaded variant is provided for
the sole purpose of setting a DOM_Node reference variable to
zero.  Nulling out a reference variable in this way will decrement
the reference count on the underlying Node object that the variable
formerly referenced.  This effect is normally obtained when reference
variable goes out of scope, but zeroing them can be useful for
global instances, or for local instances that will remain in scope
for an extended time,  when the storage belonging to the underlying
node needs to be reclaimed.


<DL><DT><B>Parameters:</B><DD><B>val.</B> -   Only a value of 0, or null, is allowed.<br></DL><P></DL>

<A NAME="Destructor. ">
<A NAME ="DOC.25.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Destructor. </B></TT>
<DL></DL><P><DL>

<A NAME="~DOM_Node">
<A NAME ="DOC.25.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  ~DOM_Node()</B></TT>
<DD>
Destructor for DOM_Node.  The object being destroyed is the reference
object, not the underlying node itself.

<DL></DL><P></DL>

<A NAME="Equality and Inequality operators. ">
<A NAME ="DOC.25.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Equality and Inequality operators. </B></TT>
<DL></DL><P><DL>

<A NAME="operator == ">
<A NAME ="DOC.25.3.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  operator == (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> & other) const </B></TT>
<DD>
The equality operator.  This compares to references to nodes, and
returns true if they both refer to the same underlying node.  It
is exactly analogous to Java's operator ==  on object reference
variables.  This operator can not be used to compare the values
of two different nodes in the document tree.


<DL><DT><B>Returns:</B><DD>s True if both <code>DOM_Node</code>s refer to the same
actual node, or are both null; return false otherwise.
<DT><B>Parameters:</B><DD><B>other</B> -  The object reference with which <code>this</code> object is compared
<br></DL><P>
<A NAME="operator == ">
<A NAME ="DOC.25.3.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  operator == (const DOM_NullPtr *other) const </B></TT>
<DD>
Compare with a pointer.  Intended only to allow a convenient
comparison with null.

<DL></DL><P>
<A NAME="operator != ">
<A NAME ="DOC.25.3.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  operator != (const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> & other) const </B></TT>
<DD>
The inequality operator.  See operator ==.

<DL></DL><P>
<A NAME="operator != ">
<A NAME ="DOC.25.3.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  operator != (const DOM_NullPtr * other) const </B></TT>
<DD>
Compare with a pointer.  Intended only to allow a convenient
comparison with null.

<DL></DL><P></DL>

<A NAME="Get functions. ">
<A NAME ="DOC.25.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Get functions. </B></TT>
<DL></DL><P><DL>

<A NAME="getNodeName">
<A NAME ="DOC.25.4.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOMString.html">DOMString</A>  getNodeName() const </B></TT>
<DD>
The name of this node, depending on its type; see the table above
<DL></DL><P>
<A NAME="getNodeValue">
<A NAME ="DOC.25.4.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOMString.html">DOMString</A>  getNodeValue() const </B></TT>
<DD>
Gets the value of this node, depending on its type.


<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
<br><B>DOMException</B> 
DOMSTRING_SIZE_ERR: Raised when it would return more characters than
fit in a <code>DOMString</code> variable on the implementation
platform.<br></DL><P>
<A NAME="getNodeType">
<A NAME ="DOC.25.4.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> short  getNodeType() const </B></TT>
<DD>
An enum value representing the type of the underlying object
<DL></DL><P>
<A NAME="getParentNode">
<A NAME ="DOC.25.4.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  getParentNode() const </B></TT>
<DD>
Gets the parent of this node.

All nodes, except <code>Document</code>,
<code>DocumentFragment</code>, and <code>Attr</code> may have a parent.
However, if a node has just been created and not yet added to the tree,
or if it has been removed from the tree, a <code>null</code> DOM_Node
is returned.
<DL></DL><P>
<A NAME="getChildNodes">
<A NAME ="DOC.25.4.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_NodeList.html">DOM_NodeList</A>  getChildNodes() const </B></TT>
<DD>
Gets a <code>NodeList</code> that contains all children of this node.

If there
are no children, this is a <code>NodeList</code> containing no nodes.
The content of the returned <code>NodeList</code> is "live" in the sense
that, for instance, changes to the children of the node object that
it was created from are immediately reflected in the nodes returned by
the <code>NodeList</code> accessors; it is not a static snapshot of the
content of the node. This is true for every <code>NodeList</code>,
including the ones returned by the <code>getElementsByTagName</code>
method.
<DL></DL><P>
<A NAME="getFirstChild">
<A NAME ="DOC.25.4.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  getFirstChild() const </B></TT>
<DD>
Gets the first child of this node.

If there is no such node, this returns <code>null</code>.
<DL></DL><P>
<A NAME="getLastChild">
<A NAME ="DOC.25.4.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  getLastChild() const </B></TT>
<DD>
Gets the last child of this node.

If there is no such node, this returns <code>null</code>.
<DL></DL><P>
<A NAME="getPreviousSibling">
<A NAME ="DOC.25.4.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  getPreviousSibling() const </B></TT>
<DD>
Gets the node immediately preceding this node.

If there is no such node, this returns <code>null</code>.
<DL></DL><P>
<A NAME="getNextSibling">
<A NAME ="DOC.25.4.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  getNextSibling() const </B></TT>
<DD>
Gets the node immediately following this node.

If there is no such node, this returns <code>null</code>.
<DL></DL><P>
<A NAME="getAttributes">
<A NAME ="DOC.25.4.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_NamedNodeMap.html">DOM_NamedNodeMap</A>  getAttributes() const </B></TT>
<DD>
Gets a <code>NamedNodeMap</code> containing the attributes of this node (if it
is an <code>Element</code>) or <code>null</code> otherwise
<DL></DL><P>
<A NAME="getOwnerDocument">
<A NAME ="DOC.25.4.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOM_Document.html">DOM_Document</A>  getOwnerDocument() const </B></TT>
<DD>
Gets the <code>DOM_Document</code> object associated with this node.

This is also
the <code>DOM_Document</code> object used to create new nodes. When this
node is a <code>DOM_Document</code> or a <code>DOM_DocumentType</code>
which is not used with any <code>DOM_Document</code> yet, this is
<code>null</code>.

<p><b>"Experimental - subject to change"</b></p>

<DL></DL><P>
<A NAME="getUserData">
<A NAME ="DOC.25.4.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void*  getUserData() const </B></TT>
<DD>
Return the user data pointer.

User data allows application programs
to attach extra data to DOM nodes, and can be set using the
function <code>DOM_Node::setUserData(p)</code>.

<DL><DT><B>Returns:</B><DD>The user data pointer.
</DL><P></DL>

<A NAME="Cloning function. ">
<A NAME ="DOC.25.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Cloning function. </B></TT>
<DL></DL><P><DL>

<A NAME="cloneNode">
<A NAME ="DOC.25.5.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  cloneNode(bool deep) const </B></TT>
<DD>
Returns a duplicate of this node.

This function serves as a generic copy constructor for nodes.

The duplicate node has no parent (
<code>parentNode</code> returns <code>null</code>.).
<br>Cloning an <code>Element</code> copies all attributes and their
values, including those generated by the  XML processor to represent
defaulted attributes, but this method does not copy any text it contains
unless it is a deep clone, since the text is contained in a child
<code>Text</code> node. Cloning any other type of node simply returns a
copy of this node.

<DL><DT><B>Returns:</B><DD>The duplicate node.
<DT><B>Parameters:</B><DD><B>deep</B> -  If <code>true</code>, recursively clone the subtree under the
specified node; if <code>false</code>, clone only the node itself (and
its attributes, if it is an <code>Element</code>).
<br></DL><P></DL>

<A NAME="Functions to modify the DOM Node. ">
<A NAME ="DOC.25.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Functions to modify the DOM Node. </B></TT>
<DL></DL><P><DL>

<A NAME="insertBefore">
<A NAME ="DOC.25.6.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  insertBefore(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild, const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &refChild)</B></TT>
<DD>
Inserts the node <code>newChild</code> before the existing child node
<code>refChild</code>.

If <code>refChild</code> is <code>null</code>,
insert <code>newChild</code> at the end of the list of children.
<br>If <code>newChild</code> is a <code>DocumentFragment</code> object,
all of its children are inserted, in the same order, before
<code>refChild</code>. If the <code>newChild</code> is already in the
tree, it is first removed.  Note that a <code>DOM_Node</code> that
has never been assigned to refer to an actual node is == null.

<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not
allow children of the type of the <code>newChild</code> node, or if
the node to insert is one of this node's ancestors.
<br>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
from a different document than the one that created this node.
<br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the node being
inserted is readonly.
<br>NOT_FOUND_ERR: Raised if <code>refChild</code> is not a child of
this node.<br><DT><B>Returns:</B><DD>The node being inserted.

<DT><B>Parameters:</B><DD><B>newChild</B> -  The node to insert.
<br><B>refChild</B> -  The reference node, i.e., the node before which the new
node must be inserted.
<br></DL><P>
<A NAME="replaceChild">
<A NAME ="DOC.25.6.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  replaceChild(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild, const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &oldChild)</B></TT>
<DD>
Replaces the child node <code>oldChild</code> with <code>newChild</code>
in the list of children, and returns the <code>oldChild</code> node.

If <CODE>newChild</CODE> is a <CODE>DOM_DocumentFragment</CODE> object,
<CODE>oldChild</CODE> is replaced by all of the <CODE>DOM_DocumentFragment</CODE>
children, which are inserted in the same order.

If the <code>newChild</code> is already in the tree, it is first removed.

<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not
allow children of the type of the <code>newChild</code> node, or it
the node to put in is one of this node's ancestors.
<br>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
from a different document than the one that created this node.
<br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the new node is readonly.
<br>NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child of
this node.<br><DT><B>Returns:</B><DD>The node replaced.

<DT><B>Parameters:</B><DD><B>newChild</B> -  The new node to put in the child list.
<br><B>oldChild</B> -  The node being replaced in the list.
<br></DL><P>
<A NAME="removeChild">
<A NAME ="DOC.25.6.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  removeChild(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &oldChild)</B></TT>
<DD>
Removes the child node indicated by <code>oldChild</code> from the list
of children, and returns it.


<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
<br>NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child of
this node.<br><DT><B>Returns:</B><DD>The node removed.

<DT><B>Parameters:</B><DD><B>oldChild</B> -  The node being removed.
<br></DL><P>
<A NAME="appendChild">
<A NAME ="DOC.25.6.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  appendChild(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild)</B></TT>
<DD>
Adds the node <code>newChild</code> to the end of the list of children of
this node.

If the <code>newChild</code> is already in the tree, it is
first removed.

<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not
allow children of the type of the <code>newChild</code> node, or if
the node to append is one of this node's ancestors.
<br>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
from a different document than the one that created this node.
<br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the node being
appended is readonly.<br><DT><B>Returns:</B><DD>The node added.

<DT><B>Parameters:</B><DD><B>newChild</B> -  The node to add.If it is a  <code>DocumentFragment</code>
object, the entire contents of the document fragment are moved into
the child list of this node
<br></DL><P></DL>

<A NAME="Query functions. ">
<A NAME ="DOC.25.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Query functions. </B></TT>
<DL></DL><P><DL>

<A NAME="hasChildNodes">
<A NAME ="DOC.25.7.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  hasChildNodes() const </B></TT>
<DD>
This is a convenience method to allow easy determination of whether a
node has any children.


<DL><DT><B>Returns:</B><DD><code>true</code> if the node has any children,
<code>false</code> if the node has no children.
</DL><P>
<A NAME="isNull">
<A NAME ="DOC.25.7.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  isNull() const </B></TT>
<DD>
Test whether this node is null.

This C++ class, <code>DOM_Node<code>
functions much like an object reference to an underlying Node, and
this function tests for that reference being null.  Several DOM
APIs, <code>Node.getNextSibling()</code> for example, can return null, and
this function is used to test for that condition.

<p>Operator == provides another way to perform this null test on a
DOM_Node.
<DL></DL><P></DL>

<A NAME="Set functions. ">
<A NAME ="DOC.25.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Set functions. </B></TT>
<DL></DL><P><DL>

<A NAME="setNodeValue">
<A NAME ="DOC.25.8.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setNodeValue(const <!1><A HREF="DOMString.html">DOMString</A> &nodeValue)</B></TT>
<DD>
Sets the value of the node.

Any node which can have a nodeValue (@see getNodeValue) will
also accept requests to set it to a string. The exact response to
this varies from node to node -- Attribute, for example, stores
its values in its children and has to replace them with a new Text
holding the replacement value.

For most types of Node, value is null and attempting to set it
will throw DOMException(NO_MODIFICATION_ALLOWED_ERR). This will
also be thrown if the node is read-only.
<DL></DL><P>
<A NAME="setUserData">
<A NAME ="DOC.25.8.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setUserData(void *p)</B></TT>
<DD>
Set the user data for a node.

User data allows application programs
to attach extra data to DOM nodes, and can be retrieved using the
function <code>DOM_Node::getUserData(p)</code>.
<p>
Deletion of the user data remains the responsibility of the
application program; it will not be automatically deleted when
the nodes themselves are reclaimed.

<p> Because DOM_Node is not designed to be subclassed, userdata
provides an alternative means for extending the the information
kept with nodes by an application program.


<DL><DT><B>Parameters:</B><DD><B>p</B> -  The pointer to be kept with the node.<br></DL><P></DL>

<A NAME="Functions introduced in DOM Level 2. ">
<A NAME ="DOC.25.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Functions introduced in DOM Level 2. </B></TT>
<DL></DL><P><DL>

<A NAME="normalize">
<A NAME ="DOC.25.9.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  normalize()</B></TT>
<DD>
Puts all <CODE>DOM_Text</CODE> 
nodes in the full depth of the sub-tree underneath this <CODE>DOM_Node</CODE>, 
including attribute nodes, into a "normal" form where only markup (e.g., 
tags, comments, processing instructions, CDATA sections, and entity 
references) separates <CODE>DOM_Text</CODE>
nodes, i.e., there are neither adjacent <CODE>DOM_Text</CODE>
nodes nor empty <CODE>DOM_Text</CODE>
nodes. This can be used to ensure that the DOM view of a document is the 
same as if it were saved and re-loaded, and is useful when operations 
(such as XPointer lookups) that depend on a particular document tree 
structure are to be used.
<P><B>Note:</B> In cases where the document contains <CODE>DOM_CDATASections</CODE>, 
the normalize operation alone may not be sufficient, since XPointers do 
not differentiate between <CODE>DOM_Text</CODE>
nodes and <CODE>DOM_CDATASection</CODE>
nodes.</P>

<p><b>"Experimental - subject to change"</b></p>

<DL></DL><P>
<A NAME="supports">
<A NAME ="DOC.25.9.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  supports(const <!1><A HREF="DOMString.html">DOMString</A> &feature, const <!1><A HREF="DOMString.html">DOMString</A> &version) const </B></TT>
<DD>
Tests whether the DOM implementation implements a specific
feature and that feature is supported by this node.

<p><b>"Experimental - subject to change"</b></p>


<DL><DT><B>Returns:</B><DD>Returns <code>true</code> if the specified feature is supported
on this node, <code>false</code> otherwise.
<DT><B>Parameters:</B><DD><B>feature</B> -  The string of the feature to test. This is the same
name as what can be passed to the method <code>hasFeature</code> on
<code>DOM_DOMImplementation</code>.
<br><B>version</B> -  This is the version number of the feature to test. In
Level 2, version 1, this is the string "2.0". If the version is not
specified, supporting any version of the feature will cause the
method to return <code>true</code>.
<br></DL><P>
<A NAME="getNamespaceURI">
<A NAME ="DOC.25.9.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOMString.html">DOMString</A>  getNamespaceURI() const </B></TT>
<DD>
Get the <em>namespace URI</em> of
this node, or <code>null</code> if it is unspecified.
<p>
This is not a computed value that is the result of a namespace lookup
based on an examination of the namespace declarations in scope. It is
merely the namespace URI given at creation time.
<p>
For nodes of any type other than <CODE>ELEMENT_NODE</CODE> and 
<CODE>ATTRIBUTE_NODE</CODE> and nodes created with a DOM Level 1 method, 
such as <CODE>createElement</CODE> from the <CODE>DOM_Document</CODE>
interface, this is always <CODE>null</CODE>.

<p><b>"Experimental - subject to change"</b></p>

<DL></DL><P>
<A NAME="getPrefix">
<A NAME ="DOC.25.9.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOMString.html">DOMString</A>  getPrefix() const </B></TT>
<DD>
Get the <em>namespace prefix</em>
of this node, or <code>null</code> if it is unspecified.

<p><b>"Experimental - subject to change"</b></p>

<DL></DL><P>
<A NAME="getLocalName">
<A NAME ="DOC.25.9.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DOMString.html">DOMString</A>  getLocalName() const </B></TT>
<DD>
Returns the local part of the <em>qualified name</em> of this node.
<p>
For nodes created with a DOM Level 1 method, such as
<code>createElement</code> from the <code>DOM_Document</code> interface,
it is null.

<p><b>"Experimental - subject to change"</b></p>

<DL></DL><P>
<A NAME="setPrefix">
<A NAME ="DOC.25.9.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setPrefix(const <!1><A HREF="DOMString.html">DOMString</A> &prefix)</B></TT>
<DD>
Set the <em>namespace prefix</em> of this node.
<p>
Note that setting this attribute, when permitted, changes 
the <CODE>nodeName</CODE> attribute, which holds the <EM>qualified 
name</EM>, as well as the <CODE>tagName</CODE> and <CODE>name</CODE> 
attributes of the <CODE>DOM_Element</CODE> and <CODE>DOM_Attr</CODE>
interfaces, when applicable.
<p>
Note also that changing the prefix of an 
attribute, that is known to have a default value, does not make a new 
attribute with the default value and the original prefix appear, since the 
<CODE>namespaceURI</CODE> and <CODE>localName</CODE> do not change.

<p><b>"Experimental - subject to change"</b></p>


<DL><DT><B>Throws:</B><DD><B>DOMException</B> 
INVALID_CHARACTER_ERR: Raised if the specified prefix contains
an illegal character.
<br>
NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
<br>
NAMESPACE_ERR: Raised if the specified <CODE>prefix</CODE> is 
malformed, if the <CODE>namespaceURI</CODE> of this node is 
<CODE>null</CODE>, if the specified prefix is "xml" and the 
<CODE>namespaceURI</CODE> of this node is different from 
"http:     *      and the specified prefix is "xmlns" and the 
<CODE>namespaceURI</CODE> of this node is different from 
"http:     *      the <CODE>qualifiedName</CODE> of this node is "xmlns".<br><DT><B>Parameters:</B><DD><B>prefix</B> -  The prefix of this node.
<br></DL><P></DL>
</DL>
<hr>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="DOM_ProcessingInstruction.html"> DOM_ProcessingInstruction </A><br>
<A HREF="DOM_Notation.html"> DOM_Notation </A><br>
<A HREF="DOM_EntityReference.html"> DOM_EntityReference </A><br>
<A HREF="DOM_Entity.html"> DOM_Entity </A><br>
<A HREF="DOM_Element.html"> DOM_Element </A><br>
<A HREF="DOM_DocumentType.html"> DOM_DocumentType </A><br>
<A HREF="DOM_DocumentFragment.html"> DOM_DocumentFragment </A><br>
<A HREF="DOM_Document.html"> DOM_Document </A><br>
<A HREF="DOM_CharacterData.html"> DOM_CharacterData </A><br>
<A HREF="DOM_Attr.html"> DOM_Attr </A><br>
</DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="80%">
	<TR>
		<TD WIDTH="100%" VALIGN="TOP">
			<P ALIGN="CENTER"><B>Xerces-C XML Parser for C++ Version 1.1</B><BR>
			Copyright &copy; 2000 The Apache Software Foundation. All Rights Reserved.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="100%">
			<P ALIGN="CENTER"><IMG SRC="ApacheLogo.jpg" WIDTH="387" HEIGHT="100" ALIGN="BOTTOM" BORDER="0">
		</TD>
	</TR>
</TABLE>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
