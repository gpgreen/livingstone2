<html><head><TITLE>DOM_DocumentFragment</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class   DOM_DocumentFragment : public <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> </H2><BLOCKQUOTE>

<code>DocumentFragment</code> is a "lightweight" or "minimal" 
<code>Document</code> object
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CDOM_Node,MDOM_Node.html,CDOM_DocumentFragment,MDOM_DocumentFragment.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<TABLE>
<DT><h3>Public</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.17.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Constructors and assignment operators </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.17.1.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>DOM_DocumentFragment</B> ()<br>
<I>
Default constructor for <code>DOM_DocumentFragment</code></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.17.1.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>DOM_DocumentFragment</B> (const <!2><A HREF="DOM_DocumentFragment.html#DOC.17.1.1">DOM_DocumentFragment</A> &other)<br>
<I>
Copy constructor</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.17.1.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_DocumentFragment.html#DOC.17.1.1">DOM_DocumentFragment</A>& </TD><TD><B>operator = </B> (const <!2><A HREF="DOM_DocumentFragment.html#DOC.17.1.1">DOM_DocumentFragment</A> &other)<br>
<I>
Assignment operator

</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.17.1.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_DocumentFragment.html#DOC.17.1.1">DOM_DocumentFragment</A>& </TD><TD><B>operator = </B> (const DOM_NullPtr *val)<br>
<I>
Assignment operator</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.17.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>Destructor </B> <br>
<I></I>

<TABLE>
<TR><TD VALIGN=top><A HREF="#DOC.17.2.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>~DOM_DocumentFragment</B> ()<br>
<I>
Destructor</I>
</TD></TR>
</TABLE>
</TD></TR></TABLE></DL>
<hr><H3>Inherited from <A HREF="DOM_Node.html">DOM_Node:</A></h3>

<DL>
<DL>
<DT><h3>Public</h3><DD><DT><P> <B>Cloning function. </B>

<DL>
<DT><A HREF="#DOC.25.5.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>cloneNode</B>(bool deep) const  </B>
 <DD><I>
Returns a duplicate of this node</I>

</DL>
<DT><P> <B>Destructor. </B>

<DL>
<DT><A HREF="#DOC.25.2.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>~DOM_Node</B>() </B>
 <DD><I>
Destructor for DOM_Node</I>

</DL>
<DT><P> <B>Equality and Inequality operators. </B>

<DL>
<DT><A HREF="#DOC.25.3.1"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>operator == </B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> & other) const  </B>
 <DD><I>
The equality operator</I>
<DT><A HREF="#DOC.25.3.2"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>operator == </B>(const DOM_NullPtr *other) const  </B>
 <DD><I>
Compare with a pointer</I>
<DT><A HREF="#DOC.25.3.3"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>operator != </B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> & other) const  </B>
 <DD><I>
The inequality operator</I>
<DT><A HREF="#DOC.25.3.4"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>operator != </B>(const DOM_NullPtr * other) const  </B>
 <DD><I>
Compare with a pointer</I>

</DL>
<DT><P> <B>Functions introduced in DOM Level 2. </B>

<DL>
<DT><A HREF="#DOC.25.9.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>normalize</B>() </B>
 <DD><I>
Puts all <CODE>DOM_Text</CODE> 
nodes in the full depth of the sub-tree underneath this <CODE>DOM_Node</CODE>, 
including attribute nodes, into a "normal" form where only markup (e</I>
<DT><A HREF="#DOC.25.9.2"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>supports</B>(const <!1><A HREF="DOMString.html">DOMString</A> &feature, const <!1><A HREF="DOMString.html">DOMString</A> &version) const  </B>
 <DD><I>
Tests whether the DOM implementation implements a specific
feature and that feature is supported by this node</I>
<DT><A HREF="#DOC.25.9.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A>  <B>getNamespaceURI</B>() const  </B>
 <DD><I>
Get the <em>namespace URI</em> of
this node, or <code>null</code> if it is unspecified</I>
<DT><A HREF="#DOC.25.9.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A>  <B>getPrefix</B>() const  </B>
 <DD><I>
Get the <em>namespace prefix</em>
of this node, or <code>null</code> if it is unspecified</I>
<DT><A HREF="#DOC.25.9.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A>  <B>getLocalName</B>() const  </B>
 <DD><I>
Returns the local part of the <em>qualified name</em> of this node</I>
<DT><A HREF="#DOC.25.9.6"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setPrefix</B>(const <!1><A HREF="DOMString.html">DOMString</A> &prefix) </B>
 <DD><I>
Set the <em>namespace prefix</em> of this node</I>

</DL>
<DT><P> <B>Functions to modify the DOM Node. </B>

<DL>
<DT><A HREF="#DOC.25.6.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>insertBefore</B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild, const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &refChild) </B>
 <DD><I>
Inserts the node <code>newChild</code> before the existing child node
<code>refChild</code></I>
<DT><A HREF="#DOC.25.6.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>replaceChild</B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild, const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &oldChild) </B>
 <DD><I>
Replaces the child node <code>oldChild</code> with <code>newChild</code>
in the list of children, and returns the <code>oldChild</code> node</I>
<DT><A HREF="#DOC.25.6.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>removeChild</B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &oldChild) </B>
 <DD><I>
Removes the child node indicated by <code>oldChild</code> from the list
of children, and returns it</I>
<DT><A HREF="#DOC.25.6.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>appendChild</B>(const <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A> &newChild) </B>
 <DD><I>
Adds the node <code>newChild</code> to the end of the list of children of
this node</I>

</DL>
<DT><P> <B>Get functions. </B>

<DL>
<DT><A HREF="#DOC.25.4.10"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A>  <B>getNodeName</B>() const  </B>
 <DD><I>
The name of this node, depending on its type; see the table above</I>
<DT><A HREF="#DOC.25.4.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOMString.html">DOMString</A>  <B>getNodeValue</B>() const  </B>
 <DD><I>
Gets the value of this node, depending on its type</I>
<DT><A HREF="#DOC.25.4.11"> <IMG BORDER=0 SRC=icon1.gif></A> short  <B>getNodeType</B>() const  </B>
 <DD><I>
An enum value representing the type of the underlying object</I>
<DT><A HREF="#DOC.25.4.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getParentNode</B>() const  </B>
 <DD><I>
Gets the parent of this node</I>
<DT><A HREF="#DOC.25.4.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_NodeList.html">DOM_NodeList</A>  <B>getChildNodes</B>() const  </B>
 <DD><I>
Gets a <code>NodeList</code> that contains all children of this node</I>
<DT><A HREF="#DOC.25.4.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getFirstChild</B>() const  </B>
 <DD><I>
Gets the first child of this node</I>
<DT><A HREF="#DOC.25.4.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getLastChild</B>() const  </B>
 <DD><I>
Gets the last child of this node</I>
<DT><A HREF="#DOC.25.4.6"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getPreviousSibling</B>() const  </B>
 <DD><I>
Gets the node immediately preceding this node</I>
<DT><A HREF="#DOC.25.4.7"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DOM_Node.html#DOC.25.1.1">DOM_Node</A>  <B>getNextSibling</B>() const  </B>
 <DD><I>
Gets the node immediately following this node</I>
<DT><A HREF="#DOC.25.4.12"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_NamedNodeMap.html">DOM_NamedNodeMap</A>  <B>getAttributes</B>() const  </B>
 <DD><I>
Gets a <code>NamedNodeMap</code> containing the attributes of this node (if it
is an <code>Element</code>) or <code>null</code> otherwise</I>
<DT><A HREF="#DOC.25.4.8"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DOM_Document.html">DOM_Document</A>  <B>getOwnerDocument</B>() const  </B>
 <DD><I>
Gets the <code>DOM_Document</code> object associated with this node</I>
<DT><A HREF="#DOC.25.4.9"> <IMG BORDER=0 SRC=icon1.gif></A> void*  <B>getUserData</B>() const  </B>
 <DD><I>
Return the user data pointer</I>

</DL>
<DT><P> <B>Query functions. </B>

<DL>
<DT><A HREF="#DOC.25.7.1"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>hasChildNodes</B>() const  </B>
 <DD><I>
This is a convenience method to allow easy determination of whether a
node has any children</I>
<DT><A HREF="#DOC.25.7.2"> <IMG BORDER=0 SRC=icon1.gif></A> bool  <B>isNull</B>() const  </B>
 <DD><I>
Test whether this node is null</I>

</DL>
<DT><P> <B>Set functions. </B>

<DL>
<DT><A HREF="#DOC.25.8.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setNodeValue</B>(const <!1><A HREF="DOMString.html">DOMString</A> &nodeValue) </B>
 <DD><I>
Sets the value of the node</I>
<DT><A HREF="#DOC.25.8.2"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setUserData</B>(void *p) </B>
 <DD><I>
Set the user data for a node</I>

</DL>
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

<code>DocumentFragment</code> is a "lightweight" or "minimal" 
<code>Document</code> object. 

It is very common to want to be able to 
extract a portion of a document's tree or to create a new fragment of a 
document. Imagine implementing a user command like cut or rearranging a 
document by moving fragments around. It is desirable to have an object 
which can hold such fragments and it is quite natural to use a Node for 
this purpose. While it is true that a <code>Document</code> object could 
fulfil this role,  a <code>Document</code> object can potentially be a 
heavyweight  object, depending on the underlying implementation. What is 
really needed for this is a very lightweight object.  
<code>DocumentFragment</code> is such an object.
<p>Furthermore, various operations -- such as inserting nodes as children 
of another <code>Node</code> -- may take <code>DocumentFragment</code> 
objects as arguments;  this results in all the child nodes of the 
<code>DocumentFragment</code>  being moved to the child list of this node.
<p>The children of a <code>DocumentFragment</code> node are zero or more 
nodes representing the tops of any sub-trees defining the structure of the 
document. <code>DocumentFragment</code> nodes do not need to be 
well-formed XML documents (although they do need to follow the rules 
imposed upon well-formed XML parsed entities, which can have multiple top 
nodes).  For example, a <code>DocumentFragment</code> might have only one 
child and that child node could be a <code>Text</code> node. Such a 
structure model  represents neither an HTML document nor a well-formed XML 
document.  
<p>When a <code>DocumentFragment</code> is inserted into a  
<code>Document</code> (or indeed any other <code>Node</code> that may take 
children) the children of the <code>DocumentFragment</code> and not the 
<code>DocumentFragment</code>  itself are inserted into the 
<code>Node</code>. This makes the <code>DocumentFragment</code> very 
useful when the user wishes to create nodes that are siblings; the 
<code>DocumentFragment</code> acts as the parent of these nodes so that the
user can use the standard methods from the <code>Node</code>  interface, 
such as <code>insertBefore()</code> and  <code>appendChild()</code>.  

</BLOCKQUOTE>
<DL>

<A NAME="Constructors and assignment operators ">
<A NAME ="DOC.17.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Constructors and assignment operators </B></TT>
<DL></DL><P><DL>

<A NAME="DOM_DocumentFragment">
<A NAME ="DOC.17.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DOM_DocumentFragment()</B></TT>
<DD>
Default constructor for <code>DOM_DocumentFragment</code>.  The resulting object does not
refer to an actual Document Fragment node; it will compare == to 0, and is similar
to a null object reference variable in Java.  It may subsequently be
assigned to refer to an actual Document Fragment node.
<p>
New document fragment nodes are created by DOM_Document::createDocumentFragment().

<DL></DL><P>
<A NAME="DOM_DocumentFragment">
<A NAME ="DOC.17.1.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DOM_DocumentFragment(const <!2><A HREF="DOM_DocumentFragment.html#DOC.17.1.1">DOM_DocumentFragment</A> &other)</B></TT>
<DD>
Copy constructor.  Creates a new <code>DOM_DocumentFragment</code> that refers to the
same underlying node as the original.  See also DOM_Node::clone(),
which will copy the actual Document fragment node, rather than just creating a new
reference to the original node.


<DL><DT><B>Parameters:</B><DD><B>other</B> -  The object to be copied<br></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.17.1.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_DocumentFragment.html#DOC.17.1.1">DOM_DocumentFragment</A>&  operator = (const <!2><A HREF="DOM_DocumentFragment.html#DOC.17.1.1">DOM_DocumentFragment</A> &other)</B></TT>
<DD>
Assignment operator


<DL><DT><B>Parameters:</B><DD><B>other</B> -  The object to be copied<br></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.17.1.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DOM_DocumentFragment.html#DOC.17.1.1">DOM_DocumentFragment</A>&  operator = (const DOM_NullPtr *val)</B></TT>
<DD>
Assignment operator.  This overloaded variant is provided for
the sole purpose of setting a DOM_Node reference variable to
zero.  Nulling out a reference variable in this way will decrement
the reference count on the underlying Node object that the variable
formerly referenced.  This effect is normally obtained when reference
variable goes out of scope, but zeroing them can be useful for
global instances, or for local instances that will remain in scope
for an extended time,  when the storage belonging to the underlying
node needs to be reclaimed.


<DL><DT><B>Parameters:</B><DD><B>val.</B> -   Only a value of 0, or null, is allowed.<br></DL><P></DL>

<A NAME="Destructor ">
<A NAME ="DOC.17.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Destructor </B></TT>
<DL></DL><P><DL>

<A NAME="~DOM_DocumentFragment">
<A NAME ="DOC.17.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  ~DOM_DocumentFragment()</B></TT>
<DD>
Destructor.  The object being destroyed is the reference
object, not the underlying Comment node itself.

<DL></DL><P></DL>
</DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="80%">
	<TR>
		<TD WIDTH="100%" VALIGN="TOP">
			<P ALIGN="CENTER"><B>Xerces-C XML Parser for C++ Version 1.1</B><BR>
			Copyright &copy; 2000 The Apache Software Foundation. All Rights Reserved.
		</TD>
	</TR>
	<TR>
		<TD WIDTH="100%">
			<P ALIGN="CENTER"><IMG SRC="ApacheLogo.jpg" WIDTH="387" HEIGHT="100" ALIGN="BOTTOM" BORDER="0">
		</TD>
	</TR>
</TABLE>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
