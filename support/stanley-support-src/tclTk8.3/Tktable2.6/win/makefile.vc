# Makefile.vc
#
# This makefile builds Tktable.dll, a table widget as a dynamically
# loadable Tk extension.  This makefile is suitable for use with
# Microsoft Visual C++ 4-5.
# TkTable assumes that Tcl/Tk has already been installed on Windows.
#
# This does not provide support for static builds on Windows
#
!include <ntwin32.mak>

PROJECT	= Tktable
TBL_COMMAND = table
TBL_RUNTIME = tkTable.tcl

# Project directories -- these may need to be customized for your site
#
# ROOT --	location of the source files.
# TMP_DIR --	location for .obj files.
# TOOLS32 --	location of VC++ compiler installation.
# DEST_DIR --	location of Tcl/Tk installation hierarchy
# DEST_DIRU --	same as above with "/" as path separator
#

ROOT		= ..
TMP_DIR		= .
# TOOLS32		= C:\Progra~1\DevStudio\Vc
# DEST_DIR	= C:\Progra~1\Tcl
# DEST_DIRU	= C:/Progra~1/Tcl
TOOLS32		= $(MSVCDIR)
DEST_DIR	= $(L2_ROOT)\l2-tools\stanley-jmpl\support\tclTk8.3
DEST_DIRU	= $(L2_ROOT)/l2-tools/stanley-jmpl/support/tclTk8.3

WIN_DIR		= $(ROOT)\win
GENERIC_DIR	= $(ROOT)\generic

#Get version info (this is in Makefile and C format)
!include "$(GENERIC_DIR)\version.h"

# Set your version of Tcl

TCL_VERSION	= 8.3
TCL_VER		= 83

INST_RUNTIME	= $(DEST_DIR)\lib\$(PROJECT)$(TBL_VERSION)
INST_RUNTIMEU	= $(DEST_DIRU)/lib/$(PROJECT)$(TBL_VERSION)

# NO_EMBEDDED_RUNTIME means that the tkTable.tcl file will not be embedded
# into the executable, thus the default tkTable.tcl library file will not
# be available when the library is loaded.
# If this is defined, the tkTable.tcl file must be available in a
# predefined set of directories (see docs).
#TBL_CFLAGS	+= -DNO_EMBEDDED_RUNTIME

# comment out the following line to compile with symbols
NODEBUG=1

#
# Visual C++ tools
#

PATH	= $(TOOLS32)\bin;$(PATH)
cc32	= "$(TOOLS32)\bin\cl" -I"$(TOOLS32)\include"
libpath32 = /LIBPATH:"$(TOOLS32)\lib"
CP      = copy
RM      = del

######################################################################
# Project specific targets
######################################################################

TBL_LIB_DIR	= $(ROOT)\library
# Assume that WISH is already INSTALLED
TCLSH		= $(DEST_DIR)\bin\tclsh$(TCL_VER)
WISH		= $(DEST_DIR)\bin\wish$(TCL_VER)
LIBS		= $(DEST_DIR)\lib\tclstub$(TCL_VER).lib \
		  $(DEST_DIR)\lib\tkstub$(TCL_VER).lib
INCLUDES	= -I"$(DEST_DIR)\include" -I.

DEFINES = -DDLL_BUILD -DBUILD_tkTable $(TBL_CFLAGS) \
	  -DTBL_VERSION=\"$(TBL_VERSION)\" \
	  -DTBL_COMMAND=\"$(TBL_COMMAND)\" \
	  -DTBL_RUNTIME="\"$(TBL_RUNTIME)\"" \
	  -DTBL_RUNTIME_DIR="\"$(INST_RUNTIMEU)\""

## Define this if you want to use STUBS
## This only works for the dynamic library
##
DEFINES	= $(DEFINES) -DUSE_TCL_STUBS -DUSE_TK_STUBS

#
# Global makefile settings
#
DLLOBJS = $(TMP_DIR)\tkTable.obj \
	$(TMP_DIR)\tkTableWin.obj \
	$(TMP_DIR)\tkTableTag.obj \
	$(TMP_DIR)\tkTableEdit.obj \
	$(TMP_DIR)\tkTableCell.obj \
	$(TMP_DIR)\tkTableCellSort.obj \
	$(TMP_DIR)\tkTableCmds.obj \
	$(TMP_DIR)\cmd.obj
# $(TMP_DIR)\tkTablePs.obj

DLL=$(PROJECT).dll
LIB=$(PROJECT).lib

#
# Targets
#
all: pkgIndex.tcl

test: pkgIndex.tcl
	@"$(WISH)" <<
	    lappend auto_path $(ROOT)
	    set code [catch {
		    package require $(PROJECT)
		    pack [$(TBL_COMMAND) .t]
		} msg]
	    if {$$code != 0} {
		tk_messageBox -type ok -message\
		    "$(PROJECT) failed to load and run: $$msg"
	    } else {
		tk_messageBox -type ok -message\
		    "everything seems OK for 'package require $(PROJECT)'"
	    }
	    exit $$code
<<

pkgIndex.tcl: $(DLL)
	"$(TCLSH)" << pkgIndex.tcl
	set out [open [lindex $$argv 0] w]
	puts $$out {if {[catch {package require Tcl 8.1}]} return}
	puts -nonewline $$out {package ifneeded $(PROJECT) $(TBL_VERSION) }
	puts -nonewline $$out {"package require Tk 8.1; }
	puts $$out {[list load [file join $$dir $(DLL)] $(PROJECT)]"}
	close $$out
<<

pkgIndex.tcl-NOSTUBS: $(DLL)
	"$(TCLSH)" << pkgIndex.tcl
	set out [open [lindex $$argv 0] w]
	puts $$out {if {[catch {package require Tcl $(TCL_VERSION)}]} return}
	puts -nonewline $$out {package ifneeded $(PROJECT) $(TBL_VERSION) }
	puts -nonewline $$out {"package require Tk $(TCL_VERSION); }
	puts $$out {[list load [file join $$dir $(DLL)] $(PROJECT)]"}
	close $$out
<<

$(DLL): tkTable.tcl.h $(DLLOBJS)
	$(link) $(linkdebug) $(dlllflags) $(libpath32) $(LIBS) \
		$(guilibsdll) -out:$@ $(DLLOBJS)

tkTable.tcl.h: $(TBL_LIB_DIR)\tkTable.tcl
	"$(TCLSH)" << $(TBL_LIB_DIR)\tkTable.tcl >$(TMP_DIR)\tkTable.tcl.h
	set in [open [lindex $$argv 0] r]
	while {[gets $$in line] != -1} {
	    switch -regexp -- $$line "^$$" - {^#} continue
	    regsub -all {\\} $$line {\\\\} line
	    regsub -all {"} $$line {\"} line
	    puts "\"$$line\\n\""
	}
<<

# Implicit Targets

{$(WIN_DIR)}.c{$(TMP_DIR)}.obj:
	$(cc32) $(cdebug) $(cflags) $(cvarsdll) \
		$(INCLUDES) $(DEFINES) -Fo$(TMP_DIR)\ $<

{$(GENERIC_DIR)}.c{$(TMP_DIR)}.obj:
	$(cc32) $(cdebug) $(cflags) $(cvarsdll) \
		$(INCLUDES) $(DEFINES) -Fo$(TMP_DIR)\ $<

install: $(DLL)
	if not exist "$(INST_RUNTIME)\" mkdir "$(INST_RUNTIME)"
	copy "$(TBL_LIB_DIR)\tkTable.tcl" "$(INST_RUNTIME)"
	copy "$(DLL)" "$(INST_RUNTIME)"
	copy "$(LIB)" "$(INST_RUNTIME)"
	copy pkgIndex.tcl "$(INST_RUNTIME)"

uninstall:
	-$(RM) "$(INST_RUNTIME)\tkTable.tcl"
	-$(RM) "$(INST_RUNTIME)\$(DLL)"
	-$(RM) "$(INST_RUNTIME)\$(LIB)"
	-$(RM) "$(INST_RUNTIME)\pkgIndex.tcl"

clean:
	-$(RM) $(TMP_DIR)\*.obj 2>nul
	-$(RM) $(TMP_DIR)\$(DLL) 2>nul
	-$(RM) $(TMP_DIR)\$(PROJECT).lib 2>nul
	-$(RM) $(TMP_DIR)\$(PROJECT).exp 2>nul
	-$(RM) $(TMP_DIR)\pkgIndex.tcl 2>nul
	-$(RM) $(TMP_DIR)\tkTable.tcl.h 2>nul
