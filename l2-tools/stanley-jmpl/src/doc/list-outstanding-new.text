####
#### See the file "l2-tools/disclaimers-and-notices.txt" for 
#### information on usage and redistribution of this file, 
#### and for a DISCLAIMER OF ALL WARRANTIES.
####

Date: Mon, 11 May 1998 18:33:03 -0700
From: Bill Millar <millar@ptolemy.arc.nasa.gov>

Some additional items appended down below: most capture things
we've discussed that weren't listed, others are new or things
to pursue later.

Priorities:

o get a complete spacecraft model in place:
   o with all propositions, to support ground ops.
   o professional look-and-feel, to encourage use.

o support bug fixes that hinder the above.

Bill


Will Taylor wrote:

> 13Jan98 - Summary of above
> ==========================
> o icons with names on the bottom, ala Macintosh
> o ?name handled without showing it to user, and
>   generated in Lisp code.
> o libraries of schematics / file manager issues
> o 2/4 break links
> ==========================
> ==========================
>
> 14Jan98 -
> ==========================
> o indenting in lisp-edit widgets: is there something akin to <tab> in
>   emacs for indenting the current line appropriately?
>   Place mouse cursor anywhere on line of text -- use <tab> to
>   indent it.
>
> 14Jan98 - highest priority
> ==========================
> o in the project menu, add an item "Simulation".  The idea is to
>    allow the user to test the selected project (module).  The user
>    must be able to provide values for various terminals, and then
>    press "execute" to see what the resulting state looks like, by
>    examining the visual display, and the current values of various
>    propositions, etc.  User might then want to continue from there
>    by specifying another set of terminal values and clicking again
>    on "execute"; or the user might want to start over, say by
>    clicking on "refresh" or "defaults" or somesuch.
>
> Issues with the above:
>
> o we can further discuss/design the interface/implementation
>    details.
> o this will likely involve tighter interaction between Stanley
>    and Livingstone, so we should discuss any issues with
>    the emacs server, etc, that might complicate this.
> o this simulation facility is a big win from the modeling
>    perspective.
> ==========================
>
> 02feb98 -
> ==========================
> o The defsystem file generated by menu selection "Project->Compile Project"
>   the order of modules should reflect hierarchial dependencies,
>   so that MPL warnings do not occur:
>   (rcs-thruster-palette (palette-d ?name)) is neither a module nor a component
> instance
>
> o
>
> 17feb98 - Mark Shirley, Bill Millar discussion
> ==============================================
> o make component initial mode visual, rather than in the dialog
>
> o "scratch pad" to allow cut&paste of wff prototypes to aid
>   beginning user
>
> o symbol completion in text widget editing?
>
> o resizable dialogs
>
> o icon library for components/modules - line-art rather than'
>   bitmaps => scalable
>
> o use shapes other than rectangles to differentiate between class
>   types -- use color gradations as well
>
> o inheriting terminals - ask user if not explicit terminal or terminator
>
> o ground ops custom UI: expand, collapse, hide functions on basic
>   schematic to create an contextual aggregate view. allow users to
>   annotate or add informative graphics
>
> o separate terminals/attributes from modes on component canvas.
>
> 27mar98 - Bill Millar discussion
> ==============================================
> o How to rename child terminals which are inherited up to parent
>   module, so that existing connections to it are prererved.
>   Currently, connections would not be drawn since the match is
>   make by name and type. - put component/module "buttons" into
>   their own array pirButton so that their internal identification
>   would be by pirButton index, not e.g. .master.canvas.?name.c.acs-a.b1
>   In this way the names could be changed and the connections would
>   be able to be redrawn with matching done by pirButtonIndex.
>
> 01may98 - summary of "later" items from Bill Millar
> ==============================================
> o smart default for module terminal ordering as a part of the
>   header -- editible at any time.
>
> o public/private designation in the instantiate/edit instance
>   dialog to specify public/private terminals -- this would
>   replace terminator nodes.
>
> o make Emacs-Livingstone load MIR from an image, not build it
>   from .fasl files.

Some additional items:

o Language quirk: in class defs, there's a way of specifying what
   the "initial" mode and wff are for the class.  These ought to be
   renamed "default" mode and wff, or somesuch.  Additionally,
   at instantiation time, the dialogue ought to allow the user to
   specify "initial" mode and wff for the instance that over-ride
   the default.  So for example, with a switch, one would specify
   that the default mode for the switch is "OFF", but this could
   be over-ridden at instantiation time to "ON".  This is an MPL
   problem.  Stanley needn't be limited by it.  We can talk about
   what code to generate to make this happen -- it's simple.

o wysiwyg in the dialog for the repositioning of terminals.

o Add the repositioning of terminals capability that's now in place
   at instantiation time to the class, allowing the user to specify
   the default terminal positioning for the class.  This replaces the
   "smart default for terminal ordering" item above.

o Consider adding a Cut/Paste/Copy to the Edit menu.  Operates
   on the currently selected item(s), akin to Delete menu item.

o Deleting a connection is ctrl-right-mouse, while converting
   between 2-4 break connection is right-mouse.  It's easy to
   confuse these.  Try to go with something uniform for deleting
   whatever item is selected.  Add an accelerator for the "delete"
   menu item, and go with that uniformly.

o Issue raised about mouse clicks and key usage not conforming to
   accepted standards.  For example, we have non-standard use
   of single-click -- should be double click.  Caused in part by
   quirks in tcl.

o Some odd behavior still in computing links following the move
   of a node.  Keep looking for opportunities to isolate the quirks
   and improve this.

o Balloon help values: think about what values might be displayed 
  here, if that's generally applicable.

o Add public/private information to bubble help ?  How else to
   distinguish visually that a terminal is public/private ?

o Should clicking on a terminal popup a dialog to edit that
   terminal instance ?

o Hard?: Allow attributes to appear as terminals, in addition to i/o ?
  Modules/Components have inputs/ouputs in their interface -- these
  appear as triangular "terminals" that can be repositioned, etc.  The
  above suggests considering that attributes also be allowed to appear
  as terminals.  Motivation: gives user access to legal attributes within
  each instance on the schematic.

o Hard?: Allow terminals to be placed on sides, in addition to top/bottom ?

o Should we ever allow multiple links to end up at the same input ?
   I don't think we should.  Currently we allow this.

o public/private issue: suppose I declare an input public, and that input
   already has a connection feeding into it on the schematic.  How should
   that be presented at the upper level?  It can't be an input per se, since
   the input is already determined inside the module.  So the declaration
   of public is simply saying that I wan't to have access to the value at the
   upper level.  So it ought to be an attribute, or perhaps an output, but
   not an input.

o Naming quirks.  Having Relations and Values is a bit quirky.  This is
   MPL's issue.  Nicer would be Relations and Types, where some things
   that we're currently calling relations are moved into types appropriately.
   Abstractions is perhaps too generic: consider renaming to Type Mappings.

o Keep looking to improve look-and-feel.  Graphics, default colors and fonts,
   general use of colors to convey information, lots of aesthetics issues, etc.
might
   look to adopt/borrow/exploit approaches in other well-established user
interfaces.

o Multiple editable schematics ?? Multiple viewable schematics ??  Slave
   processes, etc.

o Visual representation for relations ?  Hyperlinks ? (note that abstractions
   cover one such need we had in this regard, but there remain connections
   involving more than two terminals that can't currently be visualized.)

o Add terminals to modes within components ??  Note that each mode in
   the state diagram for a component effectively has the same interface as
   the component itself -- the model defines a relation among the inputs
   and outputs for the component when it's in that mode.

o Should attributes/terminals look so big on the schematic ??  Should they
   even *be* on the schematic, or should they be somehow separated into
   a properties/interfaces area ??  Might exploit the same approach you used
   in specifying the repositioning of terminals in an instance here to separate
   schematic/state_diagram information in modules/components, respectively,
   from their properties/interfaces information.

o Should labels be converted to upper case ??  Why not simply verbatim ??

o Revisit the issue of preventing declarations in components.

o Revisit the issue of ports.

o In abstraction dialogs, need a policy for naming the
   from and to items clearly.

XX
o Open spacecraft and preferences are ignored.  Apply
   preferences (by clicking OK in the preferences dialog)
   and the links between dynamics model and sru seem
   to get repositioned.  Though definition is not marked
   as modified for saving.

   Could not reproduce.

=============================
27May98 Bill Millar comments
=============================

o Connection dragging fails in some cases.  Play with PDU.
  
  Cannot duplicate.

o Allow resizing nodes on the fly?

o Allow preference for terminal icons (for size)?

o Why does pasting into a lisp buffer only sometimes work?

o Major item: how to specify/visualize interfaces (inputs,
  outputs, attributes) for modules and components while
  they're being defined/editted.

=============================
12Jun98 Bill Millar comments 
=============================

o In a lisp widget, press Esc.  Note that Esc- appears
  in the lisp widget's command line.  Stanley doesn't
  respond to anything after that.

  Cannot recreate.

18jun98
==============================================
o if balloon help window extends off screen, it flashes on/off

o Edit->Preferences does not work for operational slave canvases


17Aug98 - Dicussion with Bill Millar 

==============================================
o In VMPL, disambiguate the inherited labels in balloon help
  by building a compound name from the inheritance chain.

o Renaming a canvas node (component, module, etc) is actually
  a "delete/recreate" operation, not the renaming of an
  unique object.  
  The only way to have a proper "rename" is to have unique 
  static object identifiers, which do not change between
  VMPL sessions.  (base the identification numbering on
  Project ??)

o Renaming a component/module changes
  the names of its terminals which when inherited up break
  links which are dependent on the original terminal names.
  The only way to prevent this is to have unique terminal
  object identifiers.


23Nov98 - Limitations found during testing

==============================================
o In VMPL mode, the children and their descendants out to the
  leaf nodes of toplevel modules are not instantiated, so as to
  make loading faster.  If duplicately named nodes exist in
  lower levels of the schematic, they will not be found unless
  all nodes out to the leaves are instantiated, as in done when
  schematics are loaded in OPS mode.

  Full instantiation in VMPL mode would eliminate this potential problem.

o In VMPL, instantiate RT-MODULE with ?a and ?b and both these will
  be added to the header params list.  ?b does not get instantiated
  into a node until RT-MODULE is opened up.  If RT-MODULE is not
  opened up, and is deleted for whatever reason, ?a will be removed
  from the params list, but ?b will *not*, because it does not exist
  in any node which is being deleted.

  Full instantiation in VMPL mode would eliminate this potential problem.


