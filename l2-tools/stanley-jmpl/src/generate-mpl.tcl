# $Id: generate-mpl.tcl,v 1.1.1.1 2006/04/18 20:17:27 taylor Exp $
####
#### See the file "l2-tools/disclaimers-and-notices.txt" for 
#### information on usage and redistribution of this file, 
#### and for a DISCLAIMER OF ALL WARRANTIES.
####

## generate-mpl.tcl - generate Java-like base language representation
##      of MPL

## run Jmpl Lint on generated jmpl file

## % java gov.nasa.arc.l2tools.io.jmpl.JmplLint pneumatics.jmpl

## write schematic file contents as JMPL forms to user model directory
## 07jul97 wmt: new
proc writeSchematicMplForm { classType {askUserP 1} {silentP 0} } {
  global g_NM_livingstoneDefmoduleName g_NM_livingstoneDefcomponentName
  global g_NM_initializationCompleteP 

  if {! $g_NM_initializationCompleteP} {
     set askUserP 0; set silentP 1
  }
  # default is Lint 
  set jmplOpIndx 0
  set returnValue 0
  
  switch $classType { 
    component {
      set returnValue \
          [writeDefcomponentSchematicMplForm $g_NM_livingstoneDefcomponentName \
               $jmplOpIndx $askUserP $silentP]
    }
    module {
      writeDefmoduleSchematicMplForm $g_NM_livingstoneDefmoduleName \
          $jmplOpIndx $askUserP $silentP 
    }
    abstraction {
      # abstractions are folded into both structures and values
      set jmplOpIndx [writeStructureSymbolValueMplForm structure $jmplOpIndx \
                          $askUserP $silentP]
      set askUserP 0
      writeStructureSymbolValueMplForm value $jmplOpIndx $askUserP $silentP 
    }
    relation {
      # relations are folded into both structures and values
      set jmplOpIndx [writeStructureSymbolValueMplForm structure $jmplOpIndx \
                          $askUserP $silentP]
      set askUserP 0
      writeStructureSymbolValueMplForm value $jmplOpIndx $askUserP $silentP 
    }
    default {
      # structure symbol value 
      writeStructureSymbolValueMplForm $classType $jmplOpIndx $askUserP $silentP 
    }
  }
  return $returnValue 
}


## write, as defmodule Lisp form, the components and links defined in
## the current work space
## 05jan96 wmt: new
## 23sep96 wmt: write file.i-scm - an instantiatable
##              version of the schematic to instantiate into 
##              another defmodule .scm file
proc writeDefmoduleSchematicMplForm { defmoduleName jmplOpIndx askUserP \
                                        silentP } {
  global pirNodes pirNode pirEdges pirEdge g_NM_mkformNodeCompleteP
  global pirFileInfo pirClass g_NM_rootInstanceName pirClasses
  global g_NM_livingstoneDefmoduleArgList 
  global g_NM_classDefType pirClassesModule 
  global g_NM_instantiatableSchematicExtension pirClassModule
  global g_NM_paletteAbstractionList g_NM_dependentFilesExtension
  global g_NM_generatedMPLExtension g_NM_livingstoneDefmoduleArgTypeList
  global g_NM_paletteStructureList g_NM_initializationCompleteP
  global g_NM_l2ToolsP g_NM_livingstoneEMORBObject g_NM_win32P
  global pirClassComponent pirClassModule 
  global classJavaFormString inputsMplStringOrig outputsMplStringOrig
  global attributesMplStringOrig

  if {! [validSchematicP]} {
    return
  }
  set defmoduleDirectory "[preferred LIVINGSTONE_MODELS_DIR]/modules/"
  set defmodulePathName $defmoduleDirectory$defmoduleName 
  set defmodulePathName "[file rootname $defmodulePathName]$g_NM_generatedMPLExtension"
  if {$g_NM_win32P} {
    .master.canvas config -cursor watch 
  } else {
    .master.canvas config -cursor { watch red yellow }
  }

  set classJavaFormString ""
  append classJavaFormString "// this code is automatically generated by Stanley VJMPL\n"
  append classJavaFormString "// DO NOT EDIT\n\n"
  append classJavaFormString "\n\nclass $defmoduleName \{\n\n"

  set classVars [assoc class_variables pirClassModule($defmoduleName)]
  set moduleDocumentation [getClassVarDefaultValue documentation classVars]
  set moduleDocumentation [string trim $moduleDocumentation "\{\}"]
  set moduleFacts [getClassVarDefaultValue facts classVars]
  set moduleFacts [string trim $moduleFacts "\{\}"]

  set componentDefs "" ;set componentDecls {};
  set componentParamInfo {}
  foreach n $pirNodes {
    set nodeState [assoc nodeState pirNode($n)]
    set nodeClassName [assoc nodeClassName pirNode($n)]
    # leading digits are illegal identifier in java
    set nodeClassType [assoc nodeClassType pirNode($n)]
    # set str "writeDefmoduleSchematicMplForm: n $n nodeClassName `$nodeClassName'"
    # puts stderr "$str nodeState $nodeState"
    if {[isNodeInDefmoduleP $n] && \
        (! [string match $nodeClassType "terminal"]) && \
        (! [string match $nodeClassType "attribute"]) && \
        (! [string match $nodeState "parent-link"]) && \
        (! [string match $nodeClassName $defmoduleName])} {
      set argsValuesList [assoc argsValues pirNode($n)]
      if {$nodeClassType == "component"} {
        set tmpClassVars [assoc class_variables pirClassComponent($nodeClassName)]
      } else {
        set tmpClassVars [assoc class_variables pirClassModule($nodeClassName)]
      }
      set argsTypesList [getClassVarDefaultValue argTypes tmpClassVars]
      set newArgsValuesList {}
      set paramArgType ""; set paramArgValue ""
      foreach argType $argsTypesList argValue $argsValuesList {
        if {[lsearch -exact [getParameterizedTerminalTypes $argType] \
                 $argValue] == -1} {
          lappend newArgsValuesList $argValue
        } else {
          lappend paramArgType $argType
          lappend paramArgValue $argValue 
        }
      }
      set argsValuesList $newArgsValuesList
      set externalNodeName [getExternalNodeName [assoc nodeInstanceName pirNode($n)]]
      lappend componentParamInfo [list $externalNodeName $nodeClassName \
                                      $argsValuesList]
      # suffix extended structure type if value a parameterized terminal type
      set extendedClassName $nodeClassName
      # puts stderr "paramArgType $paramArgType paramArgValue $paramArgValue "
      set paramCnt 1
      foreach paramType $paramArgType paramValue $paramArgValue {
        set extendedTypeList [getParameterizedTerminalTypes $paramType]
        set paramTypeList {}; set typeCnt 1
        foreach extendedType $extendedTypeList {
          if {[string match $extendedType $paramValue]} {
            append extendedClassName "Param${paramCnt}Type${typeCnt}"
          }
          incr typeCnt 
        }
        incr paramCnt 
      }
      # puts stderr "extendedClassName $extendedClassName "
      if {$paramArgValue != ""} {
        lappend componentDecls [list "public" $extendedClassName $externalNodeName]
      } else {
        lappend componentDecls [list "public" $nodeClassName $externalNodeName]
      }
      append componentDefs "$externalNodeName = new $nodeClassName\("
      set firstP 1
      foreach argVal $argsValuesList {
        if {$firstP} {
          set firstP 0
        } else {
          append componentDefs ", "
          # append componentDecls ", "
        }
        append componentDefs $argVal
        # append componentDecls $argVal
      }
      append componentDefs "\);\n"
    }
  }

  set linkDefs {}
  foreach n $pirEdges {
    if {[isEdgeInDefmoduleP $n] && \
        (! [edgeHasDeclarationNodeP $n])} {
      getEdgeTerminals $n terminalFrom buttonFrom terminalTo buttonTo
      set expandedAbstractionType [assoc abstractionType pirEdge($n)] 
      # strip off from type prefix
      set indx [string first "." $expandedAbstractionType]
      set abstractionType [string range $expandedAbstractionType \
                               [expr {$indx + 1}] end]
      lappend linkDefs [list terminalFrom $terminalFrom terminalTo $terminalTo \
                            documentation [assoc documentation pirEdge($n)] \
                            abstractionType $abstractionType]
    }
  }
  # puts stderr "writeDefmoduleSchematicMplForm linkDefs $linkDefs"

  generateConnectionsFormList connectionsFormList linkDefs

  # puts stderr "writeDefmoduleSchematicMplForm: connectionsFormList $connectionsFormList"

  set inherit_input_terminal_defs {}; set inherit_output_terminal_defs {}
  set handleDeclarationsP 0; set inheritAllP 1
  inheritTerminalsIntoModule inherit_input_terminal_defs \
      inherit_output_terminal_defs $handleDeclarationsP $inheritAllP 

  set inputsMplString ""; set outputsMplString ""; set portsMplString ""
  set inputDecsMplString ""; set outputDecsMplString ""; set portDecsMplString ""
  set attributesMplString ""; set attributeFactsMplString ""
  set inputsMplList {}; set outputsMplList {}
  set updateMplStringsOnly 1
  # move pirClassModule into pirClass
  set pirClasses $pirClassesModule
  catch { unset pirClass }
  array set pirClass [array get pirClassModule]
  createDefmoduleInputsOutputs inputsMplString outputsMplString \
      portsMplString inputDecsMplString outputDecsMplString portDecsMplString \
      attributesMplString attributeFactsMplString inherit_input_terminal_defs \
      inherit_output_terminal_defs inputsMplList outputsMplList $updateMplStringsOnly

  # puts stderr "writeDefcomponentSchematicMplForm: B inputsMplString $inputsMplString paramArgs [getClassVarDefaultValue args classVars] "
  set paramArgs [getClassVarDefaultValue args classVars]
  set paramArgTypes [getClassVarDefaultValue argTypes classVars]
  set newParamArgs {}; set newParamArgTypes {}
  set extendedTypeArgs {}; set extendedTypeArgsTypes {}
  set inputsHaveExtendedTypesP 0; set outputsHaveExtendedTypesP 0
  set attributesHaveExtendedTypesP 0
  # are any params used as terminal types? if so, replace the arg with its
  # type, and remove it from the arg list (assumes that the arg is only
  # used in $inputsMplString $outputsMplString $attributesMplString)
  set inputsMplStringOrig $inputsMplString 
  set outputsMplStringOrig $outputsMplString 
  set attributesMplStringOrig $attributesMplString 
  foreach arg $paramArgs argType $paramArgTypes {
    if {[regexp "\\$arg " $inputsMplString] || \
            [regexp "\\$arg " $outputsMplString] || \
            [regexp "\\$arg " $attributesMplString]} {
      if {[regsub -all "\\$arg " $inputsMplString "$argType " tmp]} {
        set inputsHaveExtendedTypesP 1
        set inputsMplString $tmp
      }
      if {[regsub -all "\\$arg " $outputsMplString "$argType " tmp]} {
        set outputsHaveExtendedTypesP 1
        set outputsMplString $tmp
      }
      if {[regsub -all "\\$arg " $attributesMplString "$argType " tmp]} {
        set attributesHaveExtendedTypesP 1
        set attributesMplString $tmp
      }
      lappend extendedTypeArgs $arg; lappend extendedTypeArgsTypes $argType 
    } else {
      lappend newParamArgs $arg; lappend newParamArgTypes $argType 
    }
  }
  set paramArgs $newParamArgs; set paramArgTypes $newParamArgTypes 
  # puts stderr "writeDefcomponentSchematicMplForm: A inputsMplString $inputsMplString paramArgs $paramArgs "

  # set str "writeDefmoduleSchematicMplForm: moduleFacts $moduleFacts"
  # puts stderr "$str attributeFactsMplString $attributeFactsMplString"
  set moduleFactsString ""
  if {$moduleFacts != ""} {
    append moduleFactsString "$moduleFacts\n"
  }
  if {$attributeFactsMplString != ""} {
    append moduleFactsString "$attributeFactsMplString\n"
  }

  # component/module declarations
  append classJavaFormString "// --- structure --- \n"
  convertQMarkVarsForMPL componentDecls
  # add public terminal defs for each component/module
  foreach compDec $componentDecls {
    set compDecString "$compDec;\n"
    set compName [lindex $compDec 2]
    foreach inputList  $inputsMplList {
      set terminalName [lindex $inputList 2]
      if {[regexp "$compName\\\." $terminalName]} {
#         if {[lindex $inputList 0] == "public"} {
#           # convert first . to _public_
#           regsub "\\\." $terminalName "_public_" tmp
#           # convert all other . to _
#           regsub "\\\." $tmp "_" uscoreTerminalName
#           append compDecString "[lindex $inputList 0] [lindex $inputList 1] "
#           append compDecString "$uscoreTerminalName;\n  \{\n"
#           append compDecString "    $uscoreTerminalName = $terminalName;\n"
#           append compDecString "  \}\n"
#         } else {
#           # show private terms as comments
#           append compDecString "// [lindex $inputList 0] [lindex $inputList 1] "
#           append compDecString "$terminalName;\n"
#         }
        # .hrn file restricts which terminals are assignable
        # show public/private terms as comments
        append compDecString "// [lindex $inputList 0] [lindex $inputList 1] "
        append compDecString "$terminalName;\n"
      }
    }
    foreach outputList  $outputsMplList {
      set terminalName [lindex $outputList 2] 
      if {[regexp "$compName\\\." $terminalName]} {
#         if {[lindex $outputList 0] == "public"} {
#           # convert first . to _public_
#           regsub "\\\." $terminalName "_public_" tmp
#           # convert all other . to _
#           regsub "\\\." $tmp "_" uscoreTerminalName
#           append compDecString "[lindex $outputList 0] [lindex $outputList 1] "
#           append compDecString "$uscoreTerminalName;\n  \{\n"
#           append compDecString "    $uscoreTerminalName = $terminalName;\n"
#           append compDecString "  \}\n"
#           append compDecString "// [lindex $outputList 0] [lindex $outputList 1] "
#           append compDecString "$terminalName;\n"
#         } else {
#           # show private terms as comments
#           append compDecString "// [lindex $outputList 0] [lindex $outputList 1] "
#           append compDecString "$terminalName;\n"
#         }
        # show public/private terms as comments
        append compDecString "// [lindex $outputList 0] [lindex $outputList 1] "
        append compDecString "$terminalName;\n"
      }
    }
    append classJavaFormString $compDecString 
  }

  # define terminals and attributes
  append classJavaFormString "\n// --- inputs --- \n"
  convertQMarkVarsForMPL inputsMplString 
  append classJavaFormString $inputsMplString
  append classJavaFormString "\n// --- outputs --- \n"
  convertQMarkVarsForMPL outputsMplString 
  append classJavaFormString $outputsMplString
  append classJavaFormString "\n// --- attributes --- \n"
  convertQMarkVarsForMPL attributesMplString 
  append classJavaFormString $attributesMplString 

  # add parameter definitions and set relation -- if needed
  if {$paramArgs != ""} {
    appendParamDefsAndSetRelations module $paramArgs $paramArgTypes \
        $defmoduleName classJavaFormString
  }

  # constructor containing facts and connections
  append classJavaFormString "\n\n// --- constructor --- \n"
  append classJavaFormString [convertDocToJmplComments moduleDocumentation]
  append classJavaFormString "\{\n"

  # handle case of unconnected component/modules, so that JMPL Compiler
  # will include them in XMPL code
  # puts stderr "connectionsFormList $connectionsFormList"
  # puts stderr "componentDecls $componentDecls"
  foreach decl $componentDecls {
    set declName [lindex $decl 2]
    if {! [regexp "$declName" $connectionsFormList]} {
      append classJavaFormString "$declName==$declName;\n"
    }
  }
  # add calls to parameter set functions for components and modules,
  # if needed
  set titleFirstP 1
  foreach triple $componentParamInfo {
    set externalNodeName [lindex $triple 0]
    set nodeClassName [lindex $triple 1]
    set argsValuesList [lindex $triple 2]
    # puts stderr "writeDefmoduleSchematicMplForm: externalNodeName $externalNodeName nodeClassName $nodeClassName argsValuesList $argsValuesList"
    if {[llength $argsValuesList] > 0} {
      if {$titleFirstP} {
        set titleFirstP 0
        append classJavaFormString "// --- set parameter variable values --- \n"
      }
      convertQMarkVarsForMPL externalNodeName 
      append classJavaFormString "$externalNodeName."
      append classJavaFormString "${nodeClassName}_setParams ("
      # expand structured sublists into flat list
      set expndArgsValuesList {}
      foreach arg $argsValuesList {
        set expndArgsValuesList [concat $expndArgsValuesList $arg]
      }
      set firstP 1
      foreach arg $expndArgsValuesList {
        if {$firstP} {
          set firstP 0
        } else {
          append classJavaFormString ", "
        }
        append classJavaFormString "$arg"
      }
      append classJavaFormString ");\n"
    }
  }

  append classJavaFormString "\n// --- facts --- \n"
  convertQMarkVarsForMPL moduleFactsString 
  append classJavaFormString $moduleFactsString

  # component/module declarations are all that is needed - xmpl compiler
  # handle it
#   append classJavaFormString "\n// --- structure --- \n"
#   append classJavaFormString $componentDefs

  append classJavaFormString "\n// --- connections --- \n"
  convertQMarkVarsForMPL connectionsFormList 
  append classJavaFormString $connectionsFormList

  
  append classJavaFormString "\}\n\}\n\n"

  # define extended module classes for extended struct types of
  # inputs/outputs/attributes
  set paramsTypesList {}; set paramCnt 1
  foreach extendArg $extendedTypeArgs extendArgType $extendedTypeArgsTypes {
    # puts stderr "extendArg $extendArg extendArgType $extendArgType inputsMplStringOrig $inputsMplStringOrig outputsMplStringOrig $outputsMplStringOrig "
    set extendedTypeList [getParameterizedTerminalTypes $extendArgType]
    set paramTypeList {}; set typeCnt 1
    foreach extendedType $extendedTypeList {
      lappend paramTypeList [list "Param${paramCnt}Type${typeCnt}" \
                                 $extendArg $extendedType] 
      incr typeCnt 
    }
    lappend paramsTypesList $paramTypeList
    incr paramCnt 
  }
  # puts stderr "paramsTypesList $paramsTypesList "
  if {[llength $paramsTypesList] > 0} {
    set indexTemplateList {}
    for {set inx 0} {$inx < [llength $paramsTypesList]} {incr inx} {
      lappend indexTemplateList "null"
    }
    # filter out inputs/outputs/attributes which are not parameterized types
    filterNonParamTypes $extendedTypeArgs 

    recursiveClassGeneration $indexTemplateList $paramsTypesList $defmoduleName \
        $inputsHaveExtendedTypesP $outputsHaveExtendedTypesP \
        $attributesHaveExtendedTypesP
  }

  if {(! [file exists $defmodulePathName]) || \
          ([file exists $defmodulePathName] && \
               [file writable $defmodulePathName])} {
    set str "\nWriting MPL definition for [capitalizeWord $g_NM_classDefType]"
    puts stderr "$str `$defmoduleName' to \n    $defmodulePathName"

    # Write Java-syntax file
    set fid [open $defmodulePathName w]
    puts $fid $classJavaFormString
    close $fid

    ## offer to run Jmpl Lint on output file
    maybeRunJmplLintCompiler $defmoduleName $defmodulePathName \
        $jmplOpIndx $askUserP nil $silentP
  } else {
    set str "File: $defmodulePathName \nis not writable -- change permissions"
    puts stderr $str
    set dialogList [list tk_dialog .d "User Error" $str error 0 \
                          {DISMISS}]
    eval $dialogList
    if {$g_NM_initializationCompleteP} {
      error "Click OK"
    } else {
      if {$g_NM_l2ToolsP} {
        # exit L2Tools
        catch { $g_NM_livingstoneEMORBObject exit }
      }
      exit
    }
  }
  .master.canvas config -cursor top_left_arrow
  update
}


## append parameter definitions and set relations
## 29may00 wmt
proc appendParamDefsAndSetRelations { classType paramArgs paramArgTypes className \
                                          classJavaFormStringRef } {
  upvar $classJavaFormStringRef classJavaFormString
  global g_NM_paletteStructureList pirClassesStructure pirClassStructure 

  append classJavaFormString "\n// --- parameters --- \n"
  convertQMarkVarsForMPL paramArgs
  # parameter definitions
  foreach arg $paramArgs argType $paramArgTypes {
    append classJavaFormString "$argType $arg;\n"
  }
  # relation arg list
  append classJavaFormString "\nrelation ${className}_setParams ("
  set rwSilentP 1; set firstP 1
  set relationAssignmentsString ""
  set n 1
  # puts stderr "appendParamDefsAndSetRelations: paramArgs $paramArgs paramArgTypes $paramArgTypes "
  foreach arg $paramArgs argType $paramArgTypes {
    set expndArgList {}
    if {[lsearch -exact $g_NM_paletteStructureList $argType] >= 0} {
      if {[lsearch -exact $pirClassesStructure $argType] == -1} {
        read_workspace structure $argType $rwSilentP
      }
      set structClassVars [assoc class_variables pirClassStructure($argType)]
      set expndArgList [getClassVarDefaultValue args structClassVars]
      set expndArgTypeList [getClassVarDefaultValue argTypes structClassVars]
      set structureP 1
    } else {
      set expndArgList $arg 
      set expndArgTypeList $argType
      set structureP 0
    }
    set m 1
    # puts stderr "appendParamDefsAndSetRelations: expndArgList $expndArgList expndArgTypeList $expndArgTypeList "
    foreach expndArg $expndArgList expndArgType $expndArgTypeList {
      if {$firstP} {
        set firstP 0
      } else {
        append classJavaFormString ", "
      }
      # append classJavaFormString "$expndArgType $expndArg"
      append classJavaFormString "$expndArgType paramVal${n}_${m}"
      append relationAssignmentsString "${arg}"
      if {$structureP} {
        append relationAssignmentsString ".$expndArg"
      }
      # append relationAssignmentsString " = $expndArg;\n"
      append relationAssignmentsString " = paramVal${n}_${m};\n"
      incr m
    }
    incr n
  }
  append classJavaFormString ") \{\n"
  # relation assigments
  append classJavaFormString $relationAssignmentsString 
  append classJavaFormString "\}\n"
}


## generate the connections form string of Java-syntax forms for MPL
## 26jan99 wmt: extracted from writeDefmoduleSchematicMplForm
proc generateConnectionsFormList { connectionsFormListRef linkDefsRef } {
  upvar $connectionsFormListRef connectionsFormList
  upvar $linkDefsRef linkDefs

  set connectionsFormList ""
  foreach linkAlist $linkDefs {
    set terminalFrom [assoc terminalFrom linkAlist]
    set terminalTo [assoc terminalTo linkAlist]
    set documentation [assoc documentation linkAlist]
    set abstractionType [assoc abstractionType linkAlist]
    set documentation [string trim $documentation " "]
    append connectionsFormList [convertDocToJmplComments documentation]
    set termFromName [assoc terminal_name terminalFrom]
    set termFromName [string trim $termFromName " "]
    set termFromExtName [getExternalNodeName $termFromName]
    set termToName [assoc terminal_name terminalTo]
    set termToName [string trim $termToName " "]
    set termToExtName [getExternalNodeName $termToName]
    append connectionsFormList "$termFromExtName"
    # default abstraction type is equal  - for structured and non-structured types
    # JMPL compiler handles a = b & a != b for structured and non-structured types
    if {$abstractionType == "equal"} {
      append connectionsFormList " = $termToExtName"
    } else {
      append connectionsFormList ".${abstractionType}(${termToExtName})"
    }
    append connectionsFormList "; \n"
  }
}


## write Mpl code for a defcomponent
## 24jul97 wmt: adapted from writeDefcomponentSchematicMplForm 
proc writeDefcomponentSchematicMplForm { defcomponentName jmplOpIndx askUserP \
                                           silentP } {
  global pirNodes pirNode pirEdges pirEdge g_NM_mkformNodeCompleteP
  global pirFileInfo pirClass g_NM_rootInstanceName pirClasses
  global g_NM_livingstoneDefcomponentArgList 
  global g_NM_classDefType pirClassesComponent 
  global g_NM_instantiatableSchematicExtension pirClassComponent
  global g_NM_generatedMPLExtension g_NM_livingstoneDefcomponentArgTypeList
  global g_NM_paletteStructureList g_NM_terminalTypeValuesArray
  global pirClassStructure pirClassesStructure g_NM_initializationCompleteP
  global g_NM_l2ToolsP g_NM_livingstoneEMORBObject g_NM_win32P
  global g_NM_paletteDefsymbolList pirClassesSymbol 
  global classJavaFormString inputsMplStringOrig outputsMplStringOrig
  global attributesMplStringOrig

  if {! [validSchematicP]} {
    return
  }
  set reportNotFoundP 0
  set defcomponentDirectory "[preferred LIVINGSTONE_MODELS_DIR]/components/"
  set defcomponentPathName $defcomponentDirectory$defcomponentName 
  set defcomponentPathName "[file rootname $defcomponentPathName]$g_NM_generatedMPLExtension"
  if {$g_NM_win32P} {
    .master.canvas config -cursor watch 
  } else {
    .master.canvas config -cursor { watch red yellow }
  }

  set classJavaFormString ""
  append classJavaFormString "// this code is automatically generated by Stanley VJMPL\n"
  append classJavaFormString "// DO NOT EDIT\n\n"
  append classJavaFormString "class $defcomponentName \{\n\n"
  
  set classVars [assoc class_variables pirClassComponent($defcomponentName)]
  set componentDocumentation [getClassVarDefaultValue documentation classVars]
  set componentDocumentation [string trim $componentDocumentation "\{\}"]

  set componentBackgroundDoc [getClassVarDefaultValue background_documentation \
                                  classVars]
  set componentBackgroundDoc [string trim $componentBackgroundDoc "\{\}"]

  set componentBackgroundModel [getClassVarDefaultValue background_model classVars] 
  set componentBackgroundModel [string trim $componentBackgroundModel "\{\}"]

  ## initially will be palaced in a separate file -- the .ini file
  ## for all components of a particular root module
#   set componentInitially [getClassVarDefaultValue initially classVars] 
#   set componentInitially [string trim $componentInitially "\{\}"]
#   encapsulateLispComments componentInitially 
#   if {[string match $componentInitially ""]} {
#     set componentInitially "\{\}"
#   }
  set initialMode [getClassVarDefaultValue initial_mode classVars]

  set modeNamesList {}; set modeModelsList {}; set modeDocList {}
  set modeTransitionsString ""; set modeProbabilitiesString ""
  foreach n $pirNodes {
    set nodeClassType [assoc nodeClassType pirNode($n)]
    # set str "writeDefcomponentSchematicMplForm: n $n nodeClassName `$nodeClassName'"
    # puts stderr "$str nodeState $nodeState"
    if {[string match $nodeClassType "mode"]} {
      set nodeClassName [assoc nodeClassName pirNode($n)]
      set modeName [getExternalNodeName \
                               [assoc nodeInstanceName pirNode($n)]]
      lappend modeNamesList $modeName
      set documentation [assoc nodeDescription pirNode($n)]
      lappend modeDocList $documentation 
      set model [assoc model pirNode($n)]
      set model [string trim $model "\{\}"]
      lappend modeModelsList $model
      if {[string match $nodeClassName faultMode]} {
        set modeProb [assoc probability pirNode($n)]
        # if a symbol, convert to number, since L2 can only handle
        # tokens: likely lessLikely unlikely & rare
        set alphaP [regsub -nocase -all {^[a-z][A-Z]+} $modeProb "A" formSub]
        if {$alphaP} {
          if {[lsearch -exact $g_NM_paletteDefsymbolList \
                   $modeProb] == -1} {
            set str "Fault mode `$modeName' has probability `$modeProb'\n"
            append str "which is not a SYMBOL definition" 
            set dialogList [list tk_dialog .d "ERROR" $str error 0 {DISMISS}]
            eval $dialogList
            return 1
          }
          # convert to numerical value
          set pirClassName $modeProb 
          if {[lsearch -exact $pirClassesSymbol $pirClassName] == -1} {
            set readSilentP 1
            read_workspace symbol $pirClassName $readSilentP 
          }
          set symbolClassVars [getClassValue symbol $pirClassName class_variables]
          set modeProb [getClassVarDefaultValue form symbolClassVars]
          # puts stderr "writeDefcomponentSchematicMplForm: pirClassName $pirClassName modeProb $modeProb "
        }
        if {($modeProb <= 0.0) || ($modeProb >= 1.0)} {
          set str "Fault mode `$modeName' has probability `$modeProb'\n"
          append str "which is not > 0.0 and < 1.0" 
          set dialogList [list tk_dialog .d "ERROR" $str error 0 {DISMISS}]
          eval $dialogList
          return 1
        }
        # puts stderr "writeDefcomponentSchematicMplFor: modeProb $modeProb "
        if {$alphaP} {
          append modeProbabilitiesString \
              "// probability `$pirClassName' => $modeProb\n"
        }
        append modeProbabilitiesString \
            "failure to[string toupper $modeName 0 0]\(*, $modeName, $modeProb\) \{\n"
        ## do not know what constraints can go in here ???
        append modeProbabilitiesString "\}\n"
      }
      set transitionList [assoc transitions pirNode($n) $reportNotFoundP]
      foreach transition $transitionList {
        if {[llength $transition] > 4} {
          set transitionDefs [assoc defs transition]
          set transitionNames [alist-keys transitionDefs]
          foreach name $transitionNames {
            set transDef [assoc $name transitionDefs]
            set when [assoc when transDef]
            set when [string trim $when "\{\}"]
            set next [assoc next transDef]
            set cost [assoc cost transDef]
            set documentation [assoc documentation transDef]
            set documentation [string trim $documentation " "]
            append modeTransitionsString \
                [convertDocToJmplComments documentation]
            append modeTransitionsString \
                "transition $name\($modeName, $next\) \{\n"
            append modeTransitionsString "$when\n\}\n"
          } 
        }
      }
    }
  }
  # puts stderr "writeDefcomponentSchematicMplForm: modeDefsList $modeDefsList"

  set inherit_input_terminal_defs {}; set inherit_output_terminal_defs {}
  set handleDeclarationsP 0; set inheritAllP 1
  inheritTerminalsIntoModule inherit_input_terminal_defs \
      inherit_output_terminal_defs $handleDeclarationsP $inheritAllP 

  set inputsMplString ""; set outputsMplString ""; set portsMplString ""
  set inputDecsMplString ""; set outputDecsMplString ""; set portDecsMplString ""
  set attributesMplString ""; set attributeFactsMplString ""; set updateMplStringsOnly 1
  # move pirClassComponent to pirClass
  set pirClasses $pirClassesComponent
  catch { unset pirClass }
  array set pirClass [array get pirClassComponent]
  createDefmoduleInputsOutputs inputsMplString outputsMplString \
      portsMplString inputDecsMplString outputDecsMplString portDecsMplString \
      attributesMplString attributeFactsMplString inherit_input_terminal_defs \
      inherit_output_terminal_defs inputsMplList outputsMplList $updateMplStringsOnly

  # puts stderr "writeDefcomponentSchematicMplForm: B inputsMplString $inputsMplString paramArgs [getClassVarDefaultValue args classVars] "
  set paramArgs [getClassVarDefaultValue args classVars]
  set paramArgTypes [getClassVarDefaultValue argTypes classVars]
  set newParamArgs {}; set newParamArgTypes {}
  set extendedTypeArgs {}; set extendedTypeArgsTypes {}
  set inputsHaveExtendedTypesP 0; set outputsHaveExtendedTypesP 0
  set attributesHaveExtendedTypesP 0
  # are any params used as terminal types? if so, replace the arg with its
  # type, and remove it from the arg list (assumes that the arg is only
  # used in $inputsMplString $outputsMplString $attributesMplString)
  # puts stderr "writeDefcomponentSchematicMplForm: B paramArgs $paramArgs paramArgTypes $paramArgTypes inputsMplString $inputsMplString "
  set inputsMplStringOrig $inputsMplString 
  set outputsMplStringOrig $outputsMplString 
  set attributesMplStringOrig $attributesMplString 
  foreach arg $paramArgs argType $paramArgTypes {
    if {[regexp "\\$arg " $inputsMplString] || \
            [regexp "\\$arg " $outputsMplString] || \
            [regexp "\\$arg " $attributesMplString]} {
      if {[regsub -all "\\$arg " $inputsMplString "$argType " tmp]} {
        set inputsHaveExtendedTypesP 1
        set inputsMplString $tmp
      }
      if {[regsub -all "\\$arg " $outputsMplString "$argType " tmp]} {
        set outputsHaveExtendedTypesP 1
        set outputsMplString $tmp
      }
      if {[regsub -all "\\$arg " $attributesMplString "$argType " tmp]} {
        set attributesHaveExtendedTypesP 1
        set attributesMplString $tmp
      }
      lappend extendedTypeArgs $arg; lappend extendedTypeArgsTypes $argType 
    } else {
      lappend newParamArgs $arg; lappend newParamArgTypes $argType 
    }
  }
  set paramArgs $newParamArgs; set paramArgTypes $newParamArgTypes 
  # puts stderr "writeDefcomponentSchematicMplForm: A paramArgs $paramArgs paramArgTypes $paramArgTypes inputsMplString $inputsMplString "

  set backgroundString ""
  append backgroundString [convertDocToJmplComments componentBackgroundDoc]
  append backgroundString $componentBackgroundModel
  if {$backgroundString != ""} {
    append backgroundString "\n"
  }
  append backgroundString "// --- attribute facts --- \n"
  append backgroundString $attributeFactsMplString 

  # define terminals and attributes
  append classJavaFormString "// --- inputs --- \n"
  convertQMarkVarsForMPL inputsMplString 
  append classJavaFormString $inputsMplString
  append classJavaFormString "// --- outputs --- \n"
  convertQMarkVarsForMPL outputsMplString 
  append classJavaFormString $outputsMplString
  append classJavaFormString "// --- attributes --- \n"
  convertQMarkVarsForMPL attributesMplString 
  append classJavaFormString $attributesMplString 

  # define modes
  append classJavaFormString "// --- mode names --- \n"
  append classJavaFormString "private enum ModeType \{"
  set firstP 1
  foreach name $modeNamesList {
    if {$firstP} {
      set firstP 0
    } else {
      append classJavaFormString ", "
    }
    append classJavaFormString $name
  }
  append classJavaFormString "\};\n"
  append classJavaFormString "private ModeType mode;\n"
  append classJavaFormString "stateVector \[mode\];\n"

  # add parameter definitions and set relation -- if needed
  if {$paramArgs != ""} {
    appendParamDefsAndSetRelations component $paramArgs $paramArgTypes \
                                   $defcomponentName classJavaFormString
  }

  # constructor containing mode model code
  append classJavaFormString "\n// --- constructor --- \n"
  append classJavaFormString [convertDocToJmplComments componentDocumentation]
  append classJavaFormString "\{\n"

  append classJavaFormString "// --- background model --- \n"
  convertQMarkVarsForMPL backgroundString 
  append classJavaFormString $backgroundString 
  append classJavaFormString "\n\n// --- mode models --- \n"
  append classJavaFormString "switch \(mode\) \{\n\n"
  foreach name $modeNamesList modelForm $modeModelsList modelDoc $modeDocList {
    append classJavaFormString [convertDocToJmplComments modelDoc]
    append classJavaFormString "case $name: \n"
    if {$modelForm == ""} {
      append classJavaFormString ";\n\n"
    } else {
      convertQMarkVarsForMPL modelForm 
      append classJavaFormString "$modelForm\n\n"
    }
  }
  append classJavaFormString "\}\n\n"
  append classJavaFormString "\}\n\n"

  # transitions
  append classJavaFormString "// --- transitions --- \n"
  convertQMarkVarsForMPL modeTransitionsString 
  append classJavaFormString $modeTransitionsString
  append classJavaFormString "\n\n"
  append classJavaFormString "// --- probabilities --- \n" 
  append classJavaFormString $modeProbabilitiesString

  append classJavaFormString "\n\}\n\n"

  # define extended component classes for extended struct types of
  # inputs/outputs/attributes
  set paramsTypesList {}; set paramCnt 1
  foreach extendArg $extendedTypeArgs extendArgType $extendedTypeArgsTypes {
    # puts stderr "extendArg $extendArg extendArgType $extendArgType inputsMplStringOrig $inputsMplStringOrig outputsMplStringOrig $outputsMplStringOrig "
    set extendedTypeList [getParameterizedTerminalTypes $extendArgType]
    set paramTypeList {}; set typeCnt 1
    foreach extendedType $extendedTypeList {
      lappend paramTypeList [list "Param${paramCnt}Type${typeCnt}" \
                                 $extendArg $extendedType] 
      incr typeCnt 
    }
    lappend paramsTypesList $paramTypeList
    incr paramCnt 
  }
  # puts stderr "paramsTypesList $paramsTypesList "
  if {[llength $paramsTypesList] > 0} {
    set indexTemplateList {}
    for {set inx 0} {$inx < [llength $paramsTypesList]} {incr inx} {
      lappend indexTemplateList "null"
    }
    # filter out inputs/outputs/attributes which are not parameterized types
    filterNonParamTypes $extendedTypeArgs 

    recursiveClassGeneration $indexTemplateList $paramsTypesList $defcomponentName \
        $inputsHaveExtendedTypesP $outputsHaveExtendedTypesP \
        $attributesHaveExtendedTypesP
  }

  if {(! [file exists $defcomponentPathName]) || \
          ([file exists $defcomponentPathName] && \
               [file writable $defcomponentPathName])} {
    set str "\nWriting [capitalizeWord $g_NM_classDefType] Definition"
    puts stderr "$str `$defcomponentName' to \n    $defcomponentPathName"

    # Write Java-syntax file
    set fid [open $defcomponentPathName w]
    puts $fid $classJavaFormString
    close $fid

    ## offer to run Jmpl Lint on output file
    maybeRunJmplLintCompiler $defcomponentName $defcomponentPathName \
        $jmplOpIndx $askUserP nil $silentP
  } else {
    set str "File: $defcomponentPathName \nis not writable -- change permissions"
    puts stderr $str
    set dialogList [list tk_dialog .d "User Error" $str error 0 \
                          {DISMISS}]
    eval $dialogList
    if {$g_NM_initializationCompleteP} {
      error "Click OK"
    } else {
      if {$g_NM_l2ToolsP} {
        # exit L2Tools
        catch { $g_NM_livingstoneEMORBObject exit }
      }
      exit
    }
  }
  .master.canvas config -cursor top_left_arrow
  update
  return 0
}


## filter out inputs/outputs/attributes which are not parameterized types
## 11mar02 wmt: new
proc filterNonParamTypes { extendedTypeArgs } {
  global inputsMplStringOrig outputsMplStringOrig attributesMplStringOrig

  set newInputsString ""; set newOutputsString ""; set newAttributesString ""
  # puts stderr "B $inputsMplStringOrig"
  foreach lst [split $inputsMplStringOrig ";"] {
    if {[lsearch -exact $extendedTypeArgs [lindex $lst 0]] >= 0} {
      append newInputsString "${lst};"
    }
  }
  set inputsMplStringOrig "$newInputsString\n"
  # puts stderr "A $newInputsString" 
 
  foreach lst [split $outputsMplStringOrig ";"] {
    if {[lsearch -exact $extendedTypeArgs [lindex $lst 0]] >= 0} {
      append newOutputsString "${lst};"
    }
  }
  set outputsMplStringOrig "$newOutputsString\n"

  foreach lst [split $attributesMplStringOrig ";"] {
    if {[lsearch -exact $extendedTypeArgs [lindex $lst 0]] >= 0} {
      append newAttributesString "${lst};"
    }
  }
  set attributesMplStringOrig "$newAttributesString\n"
}


## recursively generate extended classes for parameterized terminal types
## 11mar02 wmt: new
proc recursiveClassGeneration { indexList paramsTypesList superClassName \
                                  inputsHaveExtendedTypesP outputsHaveExtendedTypesP \
                                    attributesHaveExtendedTypesP } {
  global classJavaFormString inputsMplStringOrig outputsMplStringOrig
  global attributesMplStringOrig
  
  if {[llength $paramsTypesList] == 0} {
    # puts stderr $indexList
    set className $superClassName
    set inputsString $inputsMplStringOrig
    set outputsString $outputsMplStringOrig
    set attributesString $attributesMplStringOrig 
    foreach indexTriplet $indexList {
      set paramTypeName [lindex $indexTriplet 0]
      set paramArg [lindex $indexTriplet 1]
      set paramType [lindex $indexTriplet 2]
      append className $paramTypeName 
      if {$inputsHaveExtendedTypesP} {
        regsub -all "\\$paramArg " $inputsString "$paramType " tmp
        set inputsString $tmp
      }
      if {$outputsHaveExtendedTypesP} {
        regsub -all "\\$paramArg " $outputsString "$paramType " tmp
        set outputsString $tmp
      }
      if {$attributesHaveExtendedTypesP} {
        regsub -all "\\$paramArg " $attributesString "$paramType " tmp
        set attributesString $tmp
      }
    }
    append classJavaFormString \
        "class $className extends $superClassName \{\n\n"
    if {$inputsHaveExtendedTypesP} {
      append classJavaFormString "// --- inputs --- \n"
      append classJavaFormString $inputsString
    }
    if {$outputsHaveExtendedTypesP} {
      append classJavaFormString "// --- outputs --- \n"
      append classJavaFormString $outputsString
    }
    if {$attributesHaveExtendedTypesP} {
      append classJavaFormString "// --- attributes --- \n"
      append classJavaFormString $attributesString
    }
    append classJavaFormString "\n\}\n\n"

    return
  }
  foreach item [lindex $paramsTypesList 0] {
    set replaceIndex [expr {[llength $indexList] - [llength $paramsTypesList]}]
    # puts stderr "numParms $numParms lenrootlst [llength $paramsTypesList] indexList $indexList "
    set newIndexList [lreplace $indexList $replaceIndex $replaceIndex $item]
    # puts stderr "new $newIndexList [llength $paramsTypesList]"
    recursiveClassGeneration $newIndexList [lrange $paramsTypesList 1 end] \
        $superClassName $inputsHaveExtendedTypesP $outputsHaveExtendedTypesP \
        $attributesHaveExtendedTypesP 
  }
}


### write structure/abstraction, symbol, and value Java forms
## from .scm files to MIR model directory
## write all forms into one file named familyName 
## 07jul97 wmt: new
proc writeStructureSymbolValueMplForm { classType jmplOpIndx askUserP silentP} {
  global g_NM_classTypesAList sortStructureFormsCnt
  global pirFileInfo g_NM_generatedMPLExtension 
  global g_NM_initializationCompleteP g_NM_l2ToolsP
  global g_NM_livingstoneEMORBObject g_NM_win32P

  if {$g_NM_win32P} {
    .master.canvas config -cursor watch 
  } else {
    .master.canvas config -cursor { watch red yellow }
  }
  set familyName [assoc $classType g_NM_classTypesAList]
  set schematicsDir [getSchematicDirectory family $familyName]
  pushd $schematicsDir
  set scmFiles [lsort -ascii [glob -nocomplain *$pirFileInfo(suffix)]]

  set firstP 1
  set listOfFormsString "// this code is automatically generated by Stanley VJMPL\n"
  append listOfFormsString "// DO NOT EDIT\n\n"
  if {$classType == "symbol"} {
    append listOfFormsString "enum symbols \{ \n"
  }
  set formList {}
  foreach file $scmFiles {
    lappend formList [getRSVMplFormFromScm $file]
  }
  if {$classType == "structure"} {
    # for structures, order forms so that base defs preceed extends defs
    set preSortedFormList {}
    foreach form $formList {
      set indx1 [string first "class" $form]
      set indx2 [string first "\{" $form]
      set key [string range $form $indx1 [expr {$indx2 - 2}]]
      lappend preSortedFormList [list $key $form]
    }
    set orderedKeys {}; set sortStructureFormsCnt 0
    set sortedFormList [sortStructureForms preSortedFormList orderedKeys]
    # error "test"
    set formList {}
    foreach keyForm $sortedFormList {
      lappend formList [lindex $keyForm 1]
    }
  }    
  foreach form $formList {
    if {$classType == "symbol"} {
      if {$firstP} { set firstP 0 } else { append listOfFormsString ", " }
      append listOfFormsString $form
    } else {
      append listOfFormsString "$form \n\n"
    }
  }
  if {$classType == "symbol"} {
    append listOfFormsString "\};\n"
  }
  popd
  # puts stderr "writeStructureSymbolValueLispForm: listOfFormsString $listOfFormsString"

  set modelPathName [preferred LIVINGSTONE_MODELS_DIR]/${familyName}$g_NM_generatedMPLExtension
  if {(! [file exists $modelPathName]) || \
          ([file exists $modelPathName] && \
               [file writable $modelPathName])} {
    set str "\nWriting *all* [capitalizeWord $classType] Class"
    if {($classType == "structure") || ($classType == "value")} {
      set str "$str and Abstraction/Relation Method"
    }
    puts stderr "$str Definitions to \n    $modelPathName"

    # Write Java-syntax file
    set fid [open $modelPathName w]
    puts $fid $listOfFormsString
    close $fid

    ## offer to run Jmpl Lint on output file
    set returnVal [maybeRunJmplLintCompiler "[capitalizeWord $classType]s" \
                       $modelPathName $jmplOpIndx $askUserP nil $silentP]
  } else {
    set str "File: $modelPathName \nis not writable -- change permissions"
    puts stderr $str
    set dialogList [list tk_dialog .d "User Error" $str error 0 \
                          {DISMISS}]
    eval $dialogList
    if {$g_NM_initializationCompleteP} {
      error "Click OK"
    } else {
      if {$g_NM_l2ToolsP} {
        # exit L2Tools
        catch { $g_NM_livingstoneEMORBObject exit }
      }
      exit
    }
  }

  .master.canvas config -cursor top_left_arrow
  update
  return $returnVal 
}

## recursive read of class dependency files to
## build g_NM_compileModuleFiles & g_NM_compileComponentFiles 
## 18sep97 wmt: new
proc readClassDependenciesFile { filename } {
  global g_NM_dependentFilesExtension
  global g_NM_compileModuleFiles g_NM_compileComponentFiles 

  set fid [open $filename r]
  gets $fid includedFilesList
  close $fid
  # puts stderr "readClassDependenciesFile: filename $filename includedFilesList $includedFilesList"
  set moduleFiles [assoc module includedFilesList]
  set componentFiles [assoc component includedFilesList]
  foreach file $moduleFiles {
    if {[lsearch -exact $g_NM_compileModuleFiles $file] == -1} {
      lappend g_NM_compileModuleFiles $file
    }
  }
  foreach file $componentFiles {
    if {[lsearch -exact $g_NM_compileComponentFiles $file] == -1} {
      lappend g_NM_compileComponentFiles $file
    }
  }
  foreach moduleFile $moduleFiles {
    
    readClassDependenciesFile $moduleFile$g_NM_dependentFilesExtension
  }
  # set str "readClassDependenciesFile: g_NM_compileModuleFiles $g_NM_compileModuleFiles"
  # puts stderr "$str g_NM_compileComponentFiles $g_NM_compileComponentFiles"
}


## put comments into Java syntax which will be picked up by
## the Java->XML compiler (///).  They must preceed the object 
## to which they belong
## 06jan00 wmt: new
proc convertDocToJmplComments { commentsFormRef } {
  upvar $commentsFormRef commentsForm

  if {$commentsForm == ""} {
    return ""
  } else {
    regsub -all "/" $commentsForm "" tmp1
    regsub -all "\\\n" $tmp1 "\n/// " tmp2
    return "/// $tmp2\n"
  }
}


## generate output for
## command, monitor directives to be written into .cmdmon  file
## which will be loaded into Livingstone
## AND initial state script file
## 22oct98 wmt: new
proc writeMplCmdMonFile { classType className } {
  global env g_NM_commandMonitorTerminals g_NM_terminalsFilesExtension
  global g_NM_inheritedClassInstances pirClassModule pirNode
  global pirClassModule pirFileInfo pirNodes env 
  global g_NM_createModuleFileName g_NM_cmdMonExtension
  global g_NM_scenarioExtension g_NM_allCommandMonitorForms 

  set directory [getL2ModelDirectory $classType]
  set cmdMonPathname $directory$className$g_NM_cmdMonExtension
  set initStateScriptPathname $directory$className$g_NM_scenarioExtension 

  set commandList {}; set monitorList {}; set propMonitorList {}
  set allCommandMonitorForms {}

  # find all command/monitor terminals inherited to this level
  set canvasRootId 0
  set currentNodeGroup [getCanvasRootInfo g_NM_currentNodeGroup $canvasRootId]
  foreach pirNodeIndex $pirNodes {
    set nodeClassType [assoc nodeClassType pirNode($pirNodeIndex)]
    set nodeClassName [assoc nodeClassName pirNode($pirNodeIndex)]
    set window [assoc window pirNode($pirNodeIndex)]
    set nodeState [assoc nodeState pirNode($pirNodeIndex)]
    # puts stderr "writeMplCmdMonFile: pirNodeIndex $pirNodeIndex"
    if {[string match $nodeClassType "terminal"] && \
            (! [regexp "declaration" $nodeClassName])} {
      if {[string match [assoc nodeGroupName pirNode($pirNodeIndex)] \
               $currentNodeGroup]} {
        if {[string match [assoc nodeClassName pirNode($pirNodeIndex)] \
                 "input"]} {
          set outputs [assoc outputs pirNode($pirNodeIndex)]
          set terminalForm [assoc out1 outputs]
          set direction out
        } else {
          set inputs [assoc inputs pirNode($pirNodeIndex)]
          set terminalForm [assoc in1 inputs]
          set direction in
        }
        # puts stderr "writeMplCmdMonFile: terminal terminalForm $terminalForm"
        lappend allCommandMonitorForms \
            [list terminalName [assoc terminal_name terminalForm] \
                 type [getTerminalType $terminalForm] \
                 commandMonitorType [assoc commandMonitorType terminalForm] \
                 window $window direction [getTerminalDirection $terminalForm] \
                 buttonNum 1]
      }
    } elseif {([string match $nodeClassType "component"] || \
                   ((! [string match $nodeState "parent-link"]) && \
                        [string match $nodeClassType "module"])) && \
                  [string match [assoc nodeGroupName pirNode($pirNodeIndex)] \
                       $currentNodeGroup]} {
      # set str "generateCreateModule: nodeInstanceName"
      # puts stderr "$str [assoc nodeInstanceName pirNode($pirNodeIndex)]"
      set numInputs [assoc numInputs pirNode($pirNodeIndex)]
      set inputs [assoc inputs pirNode($pirNodeIndex)]
      for {set num 1} {$num <= $numInputs} {incr num} {
#         if {[regexp "aftLO2" [assoc nodeInstanceName pirNode($pirNodeIndex)]]} {
#           set terminalForm [assoc in$num inputs]
#           set terminalName [assoc terminal_name terminalForm]
#           puts stderr "writeMplCmdMonFile: in terminalName $terminalName interfaceType [assoc interfaceType terminalForm]"
#         }
        set terminalForm [assoc in$num inputs]
        if {[assoc interfaceType terminalForm] == "public"} {
          # public - thus external
          # puts stderr "writeMplCmdMonFile: comp/mod in terminalForm $terminalForm"
          lappend allCommandMonitorForms \
              [list terminalName [assoc terminal_name terminalForm] \
                   type [getTerminalType $terminalForm] \
                   commandMonitorType [assoc commandMonitorType terminalForm] \
                   window $window direction [getTerminalDirection $terminalForm] \
                   buttonNum $num]
        }
      }

      set numOutputs [assoc numOutputs pirNode($pirNodeIndex)]
      set outputs [assoc outputs pirNode($pirNodeIndex)]
      for {set num 1} {$num <= $numOutputs} {incr num} {
#         if {[regexp "aftLO2" [assoc nodeInstanceName pirNode($pirNodeIndex)]]} {
#           set terminalForm [assoc out$num outputs]
#           set terminalName [assoc terminal_name terminalForm]
#           puts stderr "writeMplCmdMonFile: out terminalName $terminalName interfaceType [assoc interfaceType terminalForm]"
#         }
        set terminalForm [assoc out$num outputs]
        if {[assoc interfaceType terminalForm] == "public"} {
          # public - thus external
          # puts stderr "writeMplCmdMonFile: comp/mod out terminalForm $terminalForm"
          lappend allCommandMonitorForms \
              [list terminalName [assoc terminal_name terminalForm] \
                   type [getTerminalType $terminalForm] \
                   commandMonitorType [assoc commandMonitorType terminalForm] \
                   window $window direction [getTerminalDirection $terminalForm] \
                   buttonNum $num]
        }
      }
    }
  }
  # set str "generateCreateModule: allCommandMonitorForms"
  # puts stderr "$str [llength $allCommandMonitorForms] $allCommandMonitorForms"
  set g_NM_allCommandMonitorForms $allCommandMonitorForms 
  foreach cmdMonForm $allCommandMonitorForms {
    set prop [assoc terminalName cmdMonForm]
    set type [assoc type cmdMonForm]
    set commandMonitorTypePair [assoc commandMonitorType cmdMonForm] 
    set commandMonitorType [lindex $commandMonitorTypePair 0]
    set defaultTypeValue [lindex $commandMonitorTypePair 1]
    if {[llength $defaultTypeValue] > 1} {
      # structured type
      set defaultTypeValue [lindex $defaultTypeValue 0]
    }
    switch -exact -- $commandMonitorType {
      commanded { lappend commandList [list $prop $type $defaultTypeValue]}
      monitored { lappend monitorList [list $prop $type $defaultTypeValue]} 
      propMonitored { lappend propMonitorList [list $prop $type $defaultTypeValue]} 
    }
  }
  # set str "generateCreateModule: commandList $commandList"
  # puts stderr "$str monitorList $monitorList"

  set fileOutput ""
  set scriptOutput "scenario initialStateScript $className\n"
  if {! [string match $commandList ""]} {
    set firstLineP 1
    append fileOutput [generateCmdMonitorForms "newCommand" commandList \
                           scriptOutput $firstLineP]
  }
  if {! [string match $monitorList ""]} {
    if {$fileOutput == ""} { set firstLineP 1 } else { set firstLineP 0 }
    append fileOutput [generateCmdMonitorForms "newMonitor" monitorList \
                       scriptOutput $firstLineP]
  }
  # prop-monitors are ignored for now - generateCmdMonitorForms does not
  # generate the proper syntax, anyway
  #   if {! [string match $propMonitorList ""]} {
  #     append fileOutput [generateCmdMonitorForms "new-proposition-monitor" propMonitorList]
  #   }
  # do not send initial fc to Livingstone - use refresh instead
  append scriptOutput "refresh\n"

  puts stderr "Writing `$className' test harness (commanded/monitored terminals) output to"
  puts stderr "    $cmdMonPathname"
  set fid [open $cmdMonPathname w]
  writeXmlHeaderForInitAndHarness $fid
  puts $fid "<xmpl><mplHarness name=\"$className\" version=\"1.00\">"
  puts $fid $fileOutput
  puts $fid "</mplHarness></xmpl>"
  close $fid

  # do not create an initial script file -- the initial state of the
  # commands and monitors is determined by L2 reading the .hrn file
  # just send a refresh command in instantiateTestModule
#   puts stderr "Writing `$className' initial state script output to"
#   puts stderr "    $initStateScriptPathname"
#   set fid [open $initStateScriptPathname w]
#   puts $fid $scriptOutput 
#   close $fid
}


## 22oct98 wmt: new
proc generateCmdMonitorForms { formName propFormsListRef scriptOutputRef \
                                 firstLineP } {
  upvar $propFormsListRef propFormsList
  upvar $scriptOutputRef scriptOutput
  global g_NM_terminalTypeValuesArray g_NM_testInstanceName

  # puts stderr "generateCmdMonitorForms: propFormsList $propFormsList"
  set forms ""; set cmdFormP 1; set expandedFormP 0; set reportNotFoundP 0
  if {! [string match $formName "newCommand"]} {
    set cmdFormP 0
  }
  # expand structured types
  # puts stderr "\ngenerateCmdMonitorForms: propFormsList $propFormsList"
  set newPropFormsList {}
  foreach propList $propFormsList {
    set prop [lindex $propList 0]
    set type [lindex $propList 1]
    set defaultTypeValue [lindex $propList 2]
    set terminalForm [list terminal_name $prop type [list $type direction]]
    set propNameList [expandStructureTerminalNames terminalForm]
    foreach name $propNameList {
      lappend newPropFormsList [list $name $defaultTypeValue]
    }
  }
  # puts stderr "generateCmdMonitorForms: newPropFormsList $newPropFormsList"
  foreach propList $newPropFormsList {
    set attribute [lindex $propList 0]
    # regsub "$g_NM_testInstanceName\\\." $attribute "" att; set attribute $att
    set value [lindex $propList 1]
    if {$firstLineP} {
      set firstLineP 0
    } else {
      append forms "\n"
    }
    if {$cmdFormP} { 
      append forms "     <cmd name=\"[getExternalNodeName $attribute]\" />"
      append scriptOutput "progress [getExternalNodeName $attribute]=$value\n"
    } else {
      append forms "     <obs name=\"[getExternalNodeName $attribute]\" />"
      append scriptOutput "assign [getExternalNodeName $attribute]=$value\n"
    }
  }
  return $forms
}


## offer to run Jmpl Lint or Compiler on output file
## 17mar00 wmt: new
proc maybeRunJmplLintCompiler { className pathname jmplOpIndx askUserP \
                                    {jmplPathnameList nil} {silentP 0} \
                                    {instanceName nil} } {
  global g_NM_l2ToolsP 

  if {(! $g_NM_l2ToolsP) && ($jmplOpIndx == 0)} {
    # only run Lint if Stanley is running without L2Tools & Test mode
    if {$askUserP} {
      set str "Run JmplLint?"
      set dialogList [list tk_dialog .d "JMPL Processing" $str question -1 \
                          {LINT} {DISMISS}]
      set returnVal [eval $dialogList]
    } else {
      set returnVal 0
    }
    if {$returnVal == 0} {
      runJmpl Lint $className $pathname $jmplPathnameList $silentP \
          $instanceName 
    } else {
      set jmplOpIndx -1
    }
  } elseif {$jmplOpIndx == 1} {
    runJmpl Compiler $className $pathname $jmplPathnameList $silentP \
        $instanceName 
  }
  return $jmplOpIndx 
}


## run Jmpl Lint or Compiler on generated jmpl file and put output in
## filename.lint
## 01mar00 wmt: new
proc runJmpl { operation className pathname jmplPathnameList silentP \
                 instanceName } {
  global g_NM_initializationCompleteP g_NM_processingFileOpenP
  global g_NM_jmplLintExtenstion g_NM_jmplCompilerExtension
  global JAVA_BIN g_NM_menuStem g_NM_l2ToolsP env g_NM_win32P
  global STANLEY_ROOT

  # use this to inhibit canvasEnter from turning off pirWarning msg
  set g_NM_processingFileOpenP 1
  set severity 1; set msg2 ""
  if {$g_NM_win32P} {
    .master.canvas config -cursor watch 
  } else {
    .master.canvas config -cursor { watch red yellow }
  }
  pirWarning "Please Wait: running Jmpl$operation for `$className'" \
      $msg2 $severity
  update

  set inputDirectory [file dirname [file rootname $pathname]]
  # for stanley-sample-user-files workspace, write .xmpl file
  # into users stanley dir, so that non-group writable umask
  # will not cause a problem for the next user
  if {[preferred projectId] == "stanley-sample-user-files"} {
    set fileName [file tail $pathname]
    set outputPathname [file rootname "$env(HOME)/.stanley/$fileName"]
    set outputDirectory "$env(HOME)/.stanley"
  } else {
    set outputPathname [file rootname $pathname]
    set outputDirectory [file dirname $outputPathname]
  }
 if {$operation == "Lint"} {
    append outputPathname $g_NM_jmplLintExtenstion
  } elseif {$operation == "Compiler"} {
    append outputPathname $g_NM_jmplCompilerExtension
    # check if file is older than schematic files
    set compileP 0
    if {[file exists $outputPathname]} {
      set compiledFileTime [file mtime $outputPathname]
      foreach pathString $jmplPathnameList {
        if {[expr {[file mtime "$inputDirectory/$pathString"] > $compiledFileTime}]} {
          set compileP 1
          break
        }
      }
    } else {
      set compileP 1
    }
  } else {
    error "runJmpl: operation $operation not handled"
  }
  if {($operation == "Lint") || (($operation == "Compiler") && $compileP)} {
    puts stderr "Writing `$className' $operation output to"
    puts stderr "    $outputPathname"
    file delete $outputPathname
    file delete "${outputPathname}-err"
    file delete "${outputPathname}-out"
  }
  # note that alias's do not work under exec -- use java absolute path
  if {$operation == "Lint"} {
    # Lint has different args
    if [ catch { exec $JAVA_BIN/java gov.nasa.arc.l2tools.io.jmpl.Jmpl$operation \
                     $pathname > $outputPathname 2> "${outputPathname}-err" } ] {
      puts stderr "runJmpl: error occured in call to Jmpl$operation"
    }
    
  } elseif {($operation == "Compiler") && $compileP} {
    pushd $inputDirectory 
    # puts stderr "runJmpl args: $className $jmplPathnameList" 
    if {! $g_NM_win32P} {
      set paramList \
          [list exec $JAVA_BIN/java gov.nasa.arc.l2tools.io.jmpl.Jmpl$operation]
    } else {
      set paramList \
          [list $JAVA_BIN/java gov.nasa.arc.l2tools.io.jmpl.Jmpl$operation]
    }
    if {[preferred StanleyEliminateUnreferencedJmplVars] == "on"} {
      lappend paramList "-o"
    }
    lappend paramList $className
    lappend paramList $instanceName
    foreach pathString $jmplPathnameList {
      lappend paramList $pathString
    }

    if {! $g_NM_win32P} {
      lappend paramList ">" "${outputPathname}-out"
      lappend paramList "2>" "${outputPathname}-err"
      # puts stderr "runJmpl: paramList $paramList"
      if [ catch { eval $paramList } result ] {
        puts stderr "runJmpl: error occured in call to Jmpl$operation"
        puts stderr "         $result"
        return
      }
    } else { 
      set batchList [list $STANLEY_ROOT/bin/redir.exe]
      set splitList [split "${outputPathname}-out" "/"]
      set outPath [join $splitList "\\"]
      lappend batchList "-o" $outPath
      set splitList [split "${outputPathname}-err" "/"]
      set errPath [join $splitList "\\"]
      lappend batchList "-e" $errPath
      lappend batchList [lindex $paramList 0] [lindex $paramList 1]
      # make single slashs & single back-slashes into double back-slashes
      set splitList [split $batchList "\\"]
      set batchList [join $splitList "\\\\"]
      set splitList [split $batchList "/"]
      set batchList [join $splitList "\\\\"]
      # remove {}'s
      regsub -all "{" $batchList "" tmp
      regsub -all "}" $tmp "" batchList
      # put list of file names in a separate file which
      # the compiler will call, since Win98 MS-DOS has
      # a 962 character limit on any command line
      set paramList [lrange $paramList 2 end]
      set splitList [split $paramList "/"]
      set paramList [join $splitList "\\\\"]
      # remove {}'s
      regsub -all "{" $paramList "" tmp
      regsub -all "}" $tmp "" paramList
      # puts stderr "runJmpl: batchList $batchList"
      # puts stderr "runJmpl: paramList $paramList"
      # puts stderr "CLASSPATH: $env(CLASSPATH)"
      # execution of shell scripts does not work when
      # Tcl is built under native Windows
      # use MS-DOS batch file to execute it
      set compileScriptFilename compileJmpl.bat
      set compileArgFilename compileJmpl.arg
      file delete $compileScriptFilename
      file delete $compileArgFilename
      file delete $outPath
      file delete $errPath
      lappend batchList $compileArgFilename
      set fid [open $compileScriptFilename w]
      puts $fid "echo off"
      # build cmd line
      foreach param $batchList {
        puts -nonewline $fid "$param "
      }
      puts $fid ""
      close $fid
      # args are one per line
      set fid [open $compileArgFilename w]
      foreach param $paramList {
        puts $fid $param
      }
      close $fid
      update
      if [ catch { exec $compileScriptFilename } result ] {
        puts stderr "runJmpl: error occured in call to Jmpl$operation"
        puts stderr "         $result"
        return
      }
    }
    if {[file exists "$inputDirectory/${instanceName}$g_NM_jmplCompilerExtension"]} {
      # sucessful compile
      # JmplCompiler writes output to $instanceName.xmpl
      # currently loadmodel cmd reads $className.xmpl
      file rename  "$inputDirectory/${instanceName}$g_NM_jmplCompilerExtension" \
          $outputPathname
    }
    # print out JmplCompiler standard output
    puts stderr $result
  
    popd
  }

  if {$g_NM_initializationCompleteP} {
    # if no errors, disable Test->Compile
    set errorPathname "${outputPathname}-err"
    set fid [open $errorPathname r]
    set errorOutputP 0
    while {[set charCnt [gets $fid textLine]] != -1} {
      set errorOutputP 1
    }
    close $fid
    if {(! $errorOutputP) && $g_NM_l2ToolsP} {
      set menuRoot .master.$g_NM_menuStem
      $menuRoot.test.m entryconfigure "Compile" -state disabled
    }
    if {! $silentP} {
      # initializeDisplayStateBgColors called prior to $g_NM_initializationCompleteP == 1
      if {$operation == "Lint"} {
        # if there are errors, show Lint output
        if {$errorOutputP} {
          set outputPathnameSource $pathname 
        } else {
          set outputPathnameSource ""
        }
      } elseif {$operation == "Compiler"} {
        # show Compiler std out
        set outputPathnameSource "${outputPathname}-out"
      }
      showJmplOutput $operation $className $errorPathname $inputDirectory \
          $outputPathnameSource 
    }
  }
  set g_NM_processingFileOpenP 0
  .master.canvas config -cursor top_left_arrow
  standardMouseClickMsg ; # clear pirWarning msg
}


## show user Jmpl Lint or Compiler output in a dialog
## which has two panes: error and source
## 02mar00 wmt: new
proc showJmplOutput { operation className outputPathnameError inputDirectory \
                          outputPathnameSource} {
  global g_NM_jmplCompilerRootWindow 

  set textHeight 12; set textWidth 90
  set window ${g_NM_jmplCompilerRootWindow}.op${operation}_${className}
  # puts stderr "showJmplOutput: window $window"
  if {[winfo exists $window]} {
    destroy $window
  }
  set bgcolor [preferred StanleyMenuDialogBackgroundColor]
  toplevel $window -class Dialog
  if { [winfo viewable [winfo toplevel [winfo parent $window]]] } {
    wm transient $window [winfo toplevel [winfo parent $window]]
  }    
  set title "JMPL $operation: $className"
  set topPaneTitle "Error output"
  if {$operation == "Lint"} {
    set bottomPaneTitle "JMPL source"
  } elseif {$operation == "Compiler"} {
    set bottomPaneTitle "Standard output"
  }
  
  wm title $window $title 
  $window config -bg $bgcolor
  frame $window.text&button -bd 0 -bg $bgcolor -relief ridge 
  frame $window.text&button.panes -bd 0 -bg $bgcolor -relief ridge 
  # top pane error
  frame $window.text&button.panes.top -bd 0 -bg $bgcolor -relief ridge
  label $window.text&button.panes.top.label -text $topPaneTitle \
      -relief flat -anchor w
  frame $window.text&button.panes.top.right -bd 0 -bg $bgcolor -relief ridge 
  frame $window.text&button.panes.top.bottom -bd 0 -bg $bgcolor
  set topTxt [text $window.text&button.panes.top.text -setgrid true \
               -xscrollcommand "$window.text&button.panes.top.bottom.sx set" \
               -yscrollcommand "$window.text&button.panes.top.right.sy set" \
               -wrap word -font [preferred StanleyDialogEntryFont]]
  scrollbar $window.text&button.panes.top.bottom.sx -orient horiz \
      -command "$topTxt xview" -relief sunk -bd 2 
  scrollbar $window.text&button.panes.top.right.sy -orient vertical \
      -command "$topTxt yview" -relief sunken -bd 2 

  pack $window.text&button.panes.top.right.sy -side right -fill y -expand 1
  pack $window.text&button.panes.top.right -side right -fill y
  pack $window.text&button.panes.top.bottom.sx -side bottom -fill x -expand 1
  pack $window.text&button.panes.top.bottom -side bottom -fill x 
  pack $window.text&button.panes.top.text -side bottom -fill both -expand 1
  pack $window.text&button.panes.top.label -side bottom -fill both -expand 0
  pack $window.text&button.panes.top -side bottom -fill both -expand 1

  # bottom pane source
  frame $window.text&button.panes.bottom -bd 0 -bg $bgcolor -relief ridge
  label $window.text&button.panes.bottom.label -text $bottomPaneTitle \
      -relief flat -anchor w
  frame $window.text&button.panes.bottom.right -bd 0 -bg $bgcolor -relief ridge 
  frame $window.text&button.panes.bottom.bottom -bd 0 -bg $bgcolor
  set bottomTxt [text $window.text&button.panes.bottom.text -setgrid true \
                     -xscrollcommand "$window.text&button.panes.bottom.bottom.sx set" \
                     -yscrollcommand "$window.text&button.panes.bottom.right.sy set" \
                     -wrap word -font [preferred StanleyDialogEntryFont]]
  scrollbar $window.text&button.panes.bottom.bottom.sx -orient horiz \
      -command "$bottomTxt xview" -relief sunk -bd 2 
  scrollbar $window.text&button.panes.bottom.right.sy -orient vertical \
      -command "$bottomTxt yview" -relief sunken -bd 2 

  pack $window.text&button.panes.bottom.right.sy -side right -fill y -expand 1
  pack $window.text&button.panes.bottom.right -side right -fill y
  pack $window.text&button.panes.bottom.bottom.sx -side bottom -fill x -expand 1
  pack $window.text&button.panes.bottom.bottom -side bottom -fill x 
  pack $window.text&button.panes.bottom.text -side bottom -fill both -expand 1
  pack $window.text&button.panes.bottom.label -side bottom -fill both -expand 0
  pack $window.text&button.panes.bottom -side bottom -fill both -expand 1

  pack $window.text&button.panes.top $window.text&button.panes.bottom \
      -side top -fill both -expand 1
  pack $window.text&button.panes -side top -fill both -expand 1

  frame $window.text&button.b -bd 0 -bg $bgcolor -relief ridge 
  button $window.text&button.b.cancel -text " DISMISS " -relief raised \
      -command "destroy $window " -padx 5 -pady 5
  pack $window.text&button.b.cancel -side bottom -padx 0 -ipadx 0 -expand 1
  pack $window.text&button.b -side top -fill x
  pack $window.text&button -fill both -expand 1

  # characters
  $topTxt config -width $textWidth 
  $topTxt config -height $textHeight 
  $bottomTxt config -width $textWidth 
  $bottomTxt config -height $textHeight 

  # top pane - error
  set fid [open $outputPathnameError r]
  set errorOutputP 0; set lineNum 1
  if {$operation == "Lint"} {
    set markLineNumP 0
    set markLineNumber 1
  }
  while {[set charCnt [gets $fid textLine]] != -1} {
    $topTxt insert end "$textLine\n" lineNum_$lineNum
    set errorOutputP 1
    if {$operation == "Lint"} {
      # parse error output to get first line number
      if {(! $markLineNumP) && [string range $textLine 0 4] == "line "} {
        set textLine [string range $textLine 5 end]
        set indx [string first ":" $textLine]
        set markLineNumber [string range $textLine 0 [expr {$indx - 1}]]
        set markLineNumP 1
      }
      incr lineNum 
    }
  }
  close $fid
  set compilerErrorP 1
  if {! $errorOutputP} {
    $topTxt insert end "Successful.\n\n"
    $topTxt insert end "Check for warnings in `Standard output' pane\n"
    set compilerErrorP 0
    set markLineNumber -1
  }
  # scroll to line 1
  $topTxt see 0.1

  # bottom pane - source
  if {$outputPathnameSource != ""} {
    set fid [open $outputPathnameSource r]
    set lineNum 1
    if {$operation == "Compiler"} {
      set markLineNumP 0
      set markLineNumber 1
      $bottomTxt insert end "Input directory: $inputDirectory\n"
      incr lineNum 
      $bottomTxt insert end "Output directory: [file dirname $outputPathnameSource]\n"
      incr lineNum
      $bottomTxt insert end "Eliminate unreferenced Jmpl vars: "
      $bottomTxt insert end "[preferred StanleyEliminateUnreferencedJmplVars]\n"
      incr lineNum
    }
    while {[set charCnt [gets $fid textLine]] != -1} {
      $bottomTxt insert end "$textLine\n" lineNum_$lineNum
      if {$operation == "Compiler"} {
        if {(! $markLineNumP) && [string range $textLine 0 20] == \
                "JmplCompiler exiting."} {
          set markLineNumber [expr {$lineNum - 1 }]
          set markLineNumP 1
        }
      }
      incr lineNum 
    }
    close $fid
    if {(($operation == "Lint") && $markLineNumP) || \
            (($operation == "Compiler") && $markLineNumP && $compilerErrorP)} {
      $bottomTxt see ${markLineNumber}.1
      $bottomTxt tag configure lineNum_$markLineNumber \
          -background [preferred StanleyNodataStateBgColor]
    }
  }

  $topTxt config -state disabled
  $bottomTxt config -state disabled
  set xPos -1; set yPos -1
  keepDialogOnScreen $window $xPos $yPos 
}


## sort structure forms so that base defs preceed extends forms
## and so that structures of whose variable types are structures,
## follow those definitions
## 11mar00 wmt: new
proc sortStructureForms { preSortedFormListRef orderedKeysRef } {
  upvar $preSortedFormListRef preSortedFormList
  upvar $orderedKeysRef orderedKeys
  global g_NM_paletteDefvalueList sortStructureFormsCnt
  global pirClassStructure pirClassesStructure

  # puts stderr "\nsortStructureForms: orderedKeys $orderedKeys"
  set unSortedFormList {}; set sortedFormList {}
  set newOrderedKeys {}; set silentP 1
  set typeList $g_NM_paletteDefvalueList 
  foreach keyForm $preSortedFormList {
    set key [lindex $keyForm 0]
    set form [lindex $keyForm 1]
    set pirClassIndex [lindex $key 1]
    if {[lsearch -exact $pirClassesStructure $pirClassIndex] == -1} {
      read_workspace structure $pirClassIndex $silentP
    }
    set classVars [assoc class_variables pirClassStructure($pirClassIndex)]
    set argTypesList [getClassVarDefaultValue argTypes classVars]
    if {[lsearch -exact $key "extends"] == -1} {
      checkStructureTypes $argTypesList keyForm typeList sortedFormList \
          newOrderedKeys unSortedFormList
    } else {
      set parentClass [lindex $key 3]
      if {[string first $parentClass $orderedKeys] == -1} {
        lappend unSortedFormList $keyForm 
      } else {
        checkStructureTypes $argTypesList keyForm typeList sortedFormList \
            newOrderedKeys unSortedFormList
      }
    }
  }
  set orderedKeys $newOrderedKeys
  if {[llength $preSortedFormList] != [llength $sortedFormList]} {
    incr sortStructureFormsCnt
    if {$sortStructureFormsCnt > 10} {
      error "sortStructureForms in a loop: structure forms corrupted"
      return
    }
    # puts stderr "   preSortedFormList [llength $preSortedFormList]"
    # puts stderr "   sortedFormList [llength $sortedFormList]"
    set preSortedFormList [concat $sortedFormList $unSortedFormList]
    # puts stderr "   orderedKeys $orderedKeys"
    # puts stderr "   typeList $typeList"
    sortStructureForms preSortedFormList orderedKeys 
  } else {
    # puts stderr "sorted: orderedKeys $orderedKeys"
    return $sortedFormList 
  }
}


## 14mar00 wmt: new
proc checkStructureTypes { argTypesList keyFormRef typeListRef sortedFormListRef \
                               newOrderedKeysRef unSortedFormListRef } {
  upvar $keyFormRef keyForm
  upvar $typeListRef typeList
  upvar $sortedFormListRef sortedFormList
  upvar $newOrderedKeysRef newOrderedKeys
  upvar $unSortedFormListRef unSortedFormList

  set typeDefinedP 1
  foreach type $argTypesList {
    if {[lsearch -exact $typeList $type] == -1} {
      set typeDefinedP 0
      break
    }
  }
  if {$typeDefinedP} {
    set key [lindex $keyForm 0]
    lappend sortedFormList $keyForm
    lappend newOrderedKeys $key
    lappend typeList [lindex $key 1]
  } else {
    lappend unSortedFormList $keyForm
  }
}


## write xml format initialization file for selected module or component
## 27mar00 wmt: new
proc writeMplInitFile { classType className initialModeSelection } {
  global g_NM_jmplInitExtension g_NM_testInstanceName
  global g_NM_testModuleArgsValues pirClassComponent pirClassModule

  set directory [getL2ModelDirectory $classType]
  set initFilePathname "$directory$className$g_NM_jmplInitExtension"
  set fid [open $initFilePathname w]
  writeXmlHeaderForInitAndHarness $fid 
  puts $fid "<xmpl><mplInit name=\"$g_NM_testInstanceName\" version=\"1.00\">"
  foreach triple $initialModeSelection {
    ## regsub "$g_NM_testInstanceName\\\." [lindex $triple 0] "" modeName
    set modeName [lindex $triple 0] 
    puts $fid "  <assign eq=\"$modeName=[lindex $triple 1]\"/>"
  }
  # set parameter values, if any
  if {$classType == "component"} {
    set classVars [assoc class_variables pirClassComponent($className)]
  } else {
    set classVars [assoc class_variables pirClassModule($className)]
  }
  set classArgsVars [getClassVarDefaultValue "args" classVars]
  if {[llength $classArgsVars] > 0} {
    foreach argName $classArgsVars argValue $g_NM_testModuleArgsValues {
      set argName [string trimleft $argName "?"]
      puts $fid "  <assign eq=\"$g_NM_testInstanceName.$argName=$argValue\"/>"
    }
  }
  puts $fid "</mplInit></xmpl>"
  close $fid
  puts stderr "Writing `$className' initialization output to"
  puts stderr "    $initFilePathname"
}


## ask user for initial modes of components passed in
## 27mar00 wmt: new
proc askUserInitialModes { moduleName initialModeSelection } {
  global g_NM_nodeTypeRootWindow

  set initP 0; set cmdMonTypeP 0
  set dialogW $g_NM_nodeTypeRootWindow.module_init_$moduleName 
  set dialogId [getDialogId $dialogW]
  if {[winfo exists $dialogW]} {
    raise $dialogW
    return
  }
  toplevel $dialogW -class Dialog
  set text  "Specify Default Initial Mode"
  if {[llength $initialModeSelection] > 1} {
    append text "s"
  }
  wm title $dialogW $text
  wm group $dialogW [winfo toplevel [winfo parent $dialogW]]

  set bgcolor [preferred StanleyMenuDialogBackgroundColor]

  $dialogW config -bg $bgcolor
  set cmd "askUserInitialModesUpdate $dialogW"
  frame $dialogW.buttons -bg $bgcolor 
  button $dialogW.buttons.ok -text OK -relief raised \
      -command $cmd 
  $dialogW.buttons.ok configure -takefocus 0

  pack $dialogW.buttons.ok -side left -padx 5m -ipadx 2m -expand 1
  pack $dialogW.buttons -side bottom

  frame $dialogW.header -background $bgcolor -bd 0 -highlightthickness 0
  label $dialogW.header.label -highlightthickness 0 -relief flat -justify center \
      -font [preferred StanleyDialogEntryFont] -wraplength 0 \
      -text "Module: $moduleName" -fg black -bg $bgcolor
  label $dialogW.header.filler -background $bgcolor -bd 0 -highlightthickness 0 \
      -text "" 
  pack $dialogW.header.label $dialogW.header.filler -side top 
  pack $dialogW.header -side top 

  for {set i 0} {$i < [llength $initialModeSelection]} {incr i} {
    set triple [lindex $initialModeSelection $i]
    frame $dialogW.mode$i -bg $bgcolor 
    label $dialogW.mode$i.label -relief flat -justify left \
        -font [preferred StanleyDialogEntryFont] -wraplength 0 \
        -text "[lindex $triple 0]" -fg black -bg $bgcolor 

    set initialMode [lindex $triple 1] 
    set allowableModes [lindex $triple 2]
    if {([llength $allowableModes] > 1) || \
            (([llength $allowableModes] == 1) && \
                 ($initialMode == "<unspecified>"))} {
      tk_alphaOptionMenuCascade $dialogW.mode$i.optMenuButton \
          g_NM_optMenuInitMode_${dialogId}_mode$i \
          $initialMode allowableModes normal \
          $cmdMonTypeP $dialogW.mode$i
      pack $dialogW.mode$i.label \
          $dialogW.mode$i.optMenuButton -side left -ipadx 20
    } else {
      label $dialogW.mode$i.default -relief flat -justify left \
          -font [preferred StanleyDialogEntryFont] -wraplength 0 \
          -text $initialMode -fg black -bg $bgcolor 
      pack $dialogW.mode$i.label \
          $dialogW.mode$i.default -side left -ipadx 20
    }
    pack $dialogW.mode$i -side top -fill x
  }
  frame $dialogW.trailer -background $bgcolor -bd 0 
  label $dialogW.trailer.filler -background $bgcolor -bd 0 -text "" 
  pack $dialogW.trailer.filler -side top
  pack $dialogW.trailer -side top

  keepDialogOnScreen $dialogW 

  if {[winfo exists $dialogW]} {
    tkwait window $dialogW
  }
}


proc askUserInitialModesUpdate { dialogW } {

  destroy $dialogW
}


## convert Stanley internal ? variables for MPL
## ?name. => ""
## this. => ""
## ?<param> => <param>
## 30mar00 wmt: new
proc convertQMarkVarsForMPL { formRef } {
  upvar $formRef form

  regsub -all "\\\?name\\\." $form "" tmp
  regsub -all "this\\\." $tmp "" tmp2
  regsub -all "\\\?" $tmp2 "" form
}


## write MPL initialization and test harness XML schema to 
## output file
## 20apr00 wmt
proc writeXmlHeaderForInitAndHarness { fidOut } {
  global LIVINGSTONE_ROOT
  
  set schemaPath $LIVINGSTONE_ROOT/xml/xmpl.dtd
  set fidIn [open $schemaPath r]
  while {[gets $fidIn line] != -1} {
    puts $fidOut $line
  }
  close $fidIn
}


## determine classes corresponding to Livingstone loader error message: 
## Could not find variable test.fd10.pipeIn.flow mentioned in pipeIn.flow=zero
## 30may00 wmt
proc getClassesFromLivingstoneLoaderError { errorMsg } {
  global g_NM_instanceToNode pirNode
  global g_NM_testInstanceName

  set reportNotFoundP 0
  set nativeClasses {input output attribute displayState okMode faultMode}
  set indx [string first $g_NM_testInstanceName $errorMsg]
  set errorMsg [string range $errorMsg $indx end]
  set indx [string first " " $errorMsg]
  set classList {}
  set nodeInstanceName [string range $errorMsg 0 [expr {$indx - 1}]]
  if {$nodeInstanceName != ""} {
    set periodCnt [regsub -all "\\\." $nodeInstanceName " " tmp]
    # puts stderr "getClassesFromLivingstoneLoaderError: nodeInstanceName $nodeInstanceName periodCnt $periodCnt"
    for {set i 0} {$i <= $periodCnt} {incr i} {
      # puts stderr "getClassesFromLivingstoneLoaderError: nodeInstanceName $nodeInstanceName"
      set pirNodeIndex [assoc-array $nodeInstanceName g_NM_instanceToNode \
                            $reportNotFoundP]
      if {$pirNodeIndex != ""} {
        set nodeClassName [assoc nodeClassName pirNode($pirNodeIndex)]
        if {[lsearch -exact $nativeClasses $nodeClassName] == -1} {
          lappend classList $nodeClassName
        }
      }
      # reduce instance name
      set nodeInstanceName [lindex [reduceStructurePropname $nodeInstanceName] 0]
    }
  }
  return $classList
}


## create lists of dependent file names for MPL compilation
## return module name and pathname
## 04aug00 - extracted from compileTestScope
proc jmplCompilationDependentFileNames { moduleNameRef modulePathnameRef } {
  upvar $moduleNameRef moduleName
  upvar $modulePathnameRef modulePathname
  global g_NM_selectedTestScopeRoot g_NM_selectedTestScope
  global g_NM_generatedMPLExtension g_NM_dependentFilesExtension
  global g_NM_compileComponentFiles g_NM_compileModuleFiles 

  set g_NM_compileComponentFiles {}; set g_NM_compileModuleFiles {}
  set defmodelsDirectory "[preferred LIVINGSTONE_MODELS_DIR]/" 
  set defmoduleDirectory "${defmodelsDirectory}modules/" 
  set defcomponentDirectory "${defmodelsDirectory}components/" 
  if {$g_NM_selectedTestScopeRoot == "module"} {
    set moduleName $g_NM_selectedTestScope
    set modulePathname $defmoduleDirectory$moduleName$g_NM_generatedMPLExtension 
    set pwd [pwd]
    set modulesDir [getSchematicDirectory family defmodules]
    set includedFilesName $g_NM_selectedTestScope
    append includedFilesName $g_NM_dependentFilesExtension
    cd $modulesDir

    # fill g_NM_compileComponentFiles & g_NM_compileModuleFiles 
    readClassDependenciesFile $includedFilesName
    set g_NM_compileModuleFiles [concat $g_NM_compileModuleFiles \
                                     $g_NM_selectedTestScope]
    cd $pwd

  } else {
    # component
    set moduleName $g_NM_selectedTestScope
    set modulePathname $defcomponentDirectory$moduleName$g_NM_generatedMPLExtension
    set g_NM_compileComponentFiles $g_NM_selectedTestScope
  }
}


## return list of dependent absolute file pathnames for MPL compilation
## if testScopeRoot != "", "${defmodelsDirectory}$testScopeRoot 
## will be a "root" dir, and the paths will be relative to it
## 04aug00 - extracted from compileTestScope
proc jmplCompilationDependentPathnameList { {testScopeRoot ""} } {
  global g_NM_generatedMPLExtension
  global g_NM_compileComponentFiles g_NM_compileModuleFiles 

  set defmodelsDirectory "[preferred LIVINGSTONE_MODELS_DIR]/"
  if {$testScopeRoot != ""} {
    set rootDir "../"
  } else {
    set rootDir $defmodelsDirectory 
  }
  if {$testScopeRoot == "component"} {
    set defcomponentDirectory ""
    set defmoduleDirectory "../modules/"
  } elseif {$testScopeRoot == "module"} {
    set defcomponentDirectory "../components/"
    set defmoduleDirectory ""
  } else {
    set defcomponentDirectory "${defmodelsDirectory}components/"
    set defmoduleDirectory "${defmodelsDirectory}modules/"
  }
  set jmplPathnameList {}
  set symbolsFile "defsymbols$g_NM_generatedMPLExtension"
  # for new workspace where user has not yet created any symbols
  if {[file exists $defmodelsDirectory$symbolsFile]} {
    lappend jmplPathnameList ${rootDir}$symbolsFile
  }
  set valuesFile "defvalues$g_NM_generatedMPLExtension"
  if {[file exists $defmodelsDirectory$valuesFile]} {
    lappend jmplPathnameList ${rootDir}$valuesFile
  }
  set structuresFile "structures$g_NM_generatedMPLExtension"
  # for new workspace where user has not yet created any structures
  if {[file exists $defmodelsDirectory$structuresFile]} {
    lappend jmplPathnameList ${rootDir}$structuresFile
  }

  foreach comp $g_NM_compileComponentFiles {
    set componentFile "$comp$g_NM_generatedMPLExtension"
    lappend jmplPathnameList $defcomponentDirectory$componentFile
  }
  foreach module $g_NM_compileModuleFiles {
    set moduleFile "$module$g_NM_generatedMPLExtension"
    lappend jmplPathnameList $defmoduleDirectory$moduleFile
  }
  return $jmplPathnameList 
}


## create default display attribute node
## 21dec98 wmt: new
proc createDefaultDisplayStateAttribute { instanceName } {
  global g_NM_mkformNodeCompleteP g_NM_terminalInstance 
  global g_NM_displayStateType 

  set interactiveP 0; set g_NM_mkformNodeCompleteP 1
  set terminalInstanceName "$instanceName.displayState"
  set terminalType $g_NM_displayStateType
  set terminalDoc "default display state"
  set nodeName [getExternalNodeName $terminalInstanceName] 
  set terminalFacts "$nodeName = indeterminate;"
  set terminalLabel ""

  set g_NM_terminalInstance [list $terminalInstanceName $terminalType \
                                 $terminalDoc $terminalFacts $terminalLabel]
  instantiateDefinitionUpdate attribute displayState $interactiveP
}


## if displayStateProc does not exist, create from displayState attribute
## 27dec00 wmt: new
proc generateDisplayStateProc { pirNodeIndex  }  {
  global pirNode g_NM_instanceToNode pirClassComponent
  global pirClassModule g_NM_vmplTestModeP 

  set reportNotFoundP 0; set oldvalMustExistP 0
  set displayStatePropName [assoc displayStatePropName pirNode($pirNodeIndex)]
  set displayStateIndex [assoc-array $displayStatePropName g_NM_instanceToNode]
  set nodeClassName [assoc nodeClassName pirNode($pirNodeIndex)]
  set nodeClassType [assoc nodeClassType pirNode($pirNodeIndex)]
  if {[assoc displayStateProc pirNode($displayStateIndex) $reportNotFoundP] == ""} {
    # not in the instance -- if test mode, look in class -- if g_NM_vmplTestModeP
    if {(! $g_NM_vmplTestModeP) || \
            ($g_NM_vmplTestModeP && \
                 [getClassValue $nodeClassType $nodeClassName displayStateProc \
                      $reportNotFoundP] == "")} {
      set nodeInstanceName [assoc nodeInstanceName pirNode($pirNodeIndex)]
      set facts [string trimleft [assoc facts pirNode($displayStateIndex)] "\{"]
      set facts [string trimright $facts "\}"]
      # puts stderr "\n\ngenerateDisplayStateProc: nodeInstanceName $nodeInstanceName displayStateIndex $displayStateIndex nodeClassName $nodeClassName"
      set printP 0
#       if {[regexp "sv03" $nodeInstanceName]} {
#         puts stderr "/ngenerateDisplayStateProc: nodeInstanceName $nodeInstanceName"
#         set printP 1
#       }
      set displayStateProc [convertJmplToTcl $facts $nodeClassName $nodeClassType \
                                displayStateProcArgs "generateDisplayStateProc" \
                                $printP]

      arepl displayStateProc $displayStateProc pirNode($displayStateIndex) \
          $reportNotFoundP $oldvalMustExistP 
      arepl displayStateProcArgs $displayStateProcArgs pirNode($displayStateIndex) \
          $reportNotFoundP $oldvalMustExistP
      if {$g_NM_vmplTestModeP} {
        setClassValue $nodeClassType $nodeClassName displayStateProc \
            $displayStateProc $reportNotFoundP $oldvalMustExistP 
        setClassValue $nodeClassType $nodeClassName displayStateProcArgs \
            $displayStateProcArgs $reportNotFoundP $oldvalMustExistP 
      }
    } else {
      if {$g_NM_vmplTestModeP} {
        set displayStateProc [getClassValue $nodeClassType $nodeClassName \
                                  displayStateProc]
        set displayStateProcArgs [getClassValue $nodeClassType $nodeClassName \
                                      displayStateProcArgs]
        arepl displayStateProc $displayStateProc pirNode($displayStateIndex) \
            $reportNotFoundP $oldvalMustExistP 
        arepl displayStateProcArgs $displayStateProcArgs pirNode($displayStateIndex) \
            $reportNotFoundP $oldvalMustExistP        
      }
    }
  }
}


## convert displayState jmpl code to tcl code
proc convertJmplToTcl { facts nodeClassName nodeClassType \
                            displayStateProcArgsRef caller printP} {
  upvar $displayStateProcArgsRef displayStateProcArgs 
  global g_NM_vmplTestModeP g_NM_classDefType g_NM_instanceToNode
  global pirNode g_NM_defaultDisplayState g_NM_selectedTestScopeRoot

  if {! $g_NM_vmplTestModeP} {
    set canvasRootId 0
    set currentNodeGroup [getCanvasRootInfo g_NM_currentNodeGroup $canvasRootId]
    set pirNodeIndex [assoc-array $currentNodeGroup g_NM_instanceToNode]
    set nodeClassName [assoc nodeClassName pirNode($pirNodeIndex)]
  }
  # puts stderr "\n\nconvertJmplToTcl: nodeClassName $nodeClassName "
  # puts stderr "     facts `$facts' \n"
  # set displayStateProc [convertJmplToTclPrepare $facts displayStateProcArgs]
  if { [catch { convertJmplToTclPrepare $facts $nodeClassType \
                    displayStateProcArgs $printP} displayStateProc ]} {
    set displayStateProc "error: $displayStateProc"
  }
  # handle errors returned by convertJmplToTclPrepare and unexpected
  # errors from catch
  if {[regexp "error: " $displayStateProc]} {
    if {$caller == "terminalInstanceUpdate"} {
      set title "ERROR"
    } else {
      set title "Recoverable Error" 
    }
    set str "While converting display state attribute code from\n"
    append str "JMPL to TCL for class `$nodeClassName',\n"
    append str "an error occurred:\n"
    append str "\"[string range $displayStateProc 7 end]\"\n"
    if {$caller != "terminalInstanceUpdate"} {
      append str "nodeDisplayState = `indeterminate' used instead.\n"
      append str "Revise \"Edit->Header->Display Attribute\" code to correct error."
    }
    set dialogList [list tk_dialog .d $title $str error 0 {DISMISS}]
    eval $dialogList
    if {$caller == "terminalInstanceUpdate"} {
      return ""
    } else {
      set displayStateProcArgs ""
      if {($g_NM_classDefType == "component") && \
              ($g_NM_selectedTestScopeRoot != "component")} {
        lappend displayStateProcArgs "mode"
      }
      set procForm "proc getDisplayState \{ $displayStateProcArgs \} \{\n"
      append procForm "set displayState \"indeterminate\"\n"
      if {($g_NM_classDefType == "component") && \
              ($g_NM_selectedTestScopeRoot != "component")} {
        append procForm "if \{$"
        append procForm "mode = \"unknown\"\} \n"
        append procForm "  set displayState \"unknownL2Value\"\n"
      }
      append procForm "return $"
      append procForm "displayState\n\}"
      return $procForm
    }
  }
  # puts stderr "     displayStateProc `$displayStateProc'"
  # puts stderr "     displayStateProcArgs $displayStateProcArgs"
  return $displayStateProc 
}


## convert displayState jmpl code to tcl code
## prepare jmpl code for conversion
## 14dec00 wmt: new
proc convertJmplToTclPrepare { form nodeClassType variableListRef printP} {
  upvar $variableListRef variableList
  global g_NM_selectedTestScopeRoot

  set newForm ""; set closingBracketCnt 0; set level 0
  set variableList {}
  regsub -all "\\\}" $form "rightBrace" tmp
  regsub -all "\\\{" $tmp "leftBrace" form
  regsub -all ";" $form "" tmp
  # ensure spaces outside of {}'s for tcl's happiness
  regsub -all "\\\(" $tmp " \{" form
  regsub -all "\\\)" $form "\} " tmp
  regsub -all "this\\\." $tmp "" form
  if {$printP} { puts stderr "convertJmplToTclPrepare: form $form" }
  # ensure that leftBrace does not start a line -- proceed by a space
  regsub -all "\\\nleftBrace" $form " leftBrace" tmp; set form $tmp
  # split into lists by \n
  set splitList [split $form "\n"]
#   puts stderr "convertJmplToTclPrepare: splitList $splitList"
#   foreach el $splitList {
#     puts stderr "`$el'"
#   }

  # merge multi-line if forms to one line
  set newSplitList {}; set ifFormP 0
  foreach element $splitList {
    if {[regexp "//" $element]} {
      # puts stderr "comment line `$element' - discard"
    } elseif {[regexp "if " $element]} {
      set newElement {}; set ifFormP 1
      if {[regexp "\}" $element]} {
        set ifFormP 0
        lappend newSplitList [string trim $element " "]
      } else {
        set newElement [concat $newElement $element]
      }
    } elseif {$ifFormP} {
      set newElement [concat $newElement $element]
      if {[regexp "\}" $element]} {
        lappend newSplitList [string trim $newElement " "]
        set ifFormP 0
      }
    } else {
      lappend newSplitList [string trim $element " "]
    }
  }
  set splitList $newSplitList 
  if {$printP} {
    puts stderr "convertJmplToTclPrepare: multi-line splitList"
    foreach el $splitList {
      puts stderr "`$el'"
    }
  }

  # force compliance to tcl bracket rules
  set newSplitList {}; set singleLineIfP 0; set lineCnt 0
  foreach element $splitList {
    incr lineCnt
    if {$printP} { 
      puts stderr "convertJmplToTclPrepare: element `$element' singleLineIfP $singleLineIfP lineCnt $lineCnt"
    }
    if {($lineCnt == 2) && $singleLineIfP} {
      lappend newSplitList "rightBrace"
      set singleLineIfP 0
    }
    set len [string length $element]
    if {[regexp "if " $element] & (! [regexp "leftBrace" $element])} {
      lappend element "leftBrace"
      set singleLineIfP 1; set lineCnt 0 
    } elseif {[regexp "else" $element]} {
      set singleLineIfP 1; set lineCnt 0
      if {$element == "else"} {
        set element [list "else" "leftBrace"]
      } elseif {[regexp "leftBrace" $element]} {
        set singleLineIfP 0
      }
    }
    lappend newSplitList $element
  }
  if {$singleLineIfP && ($lineCnt == 1)} {
    lappend newSplitList "rightBrace"
    set singleLineIfP 0
  }
  if {$printP} { 
    puts stderr "convertJmplToTclPrepare: bracket rules splitList "
    foreach el $newSplitList {
      puts stderr "`$el'"
    }
  }

  set splitList $newSplitList 
  # merge leftBrace & {else rightBrace}
  set lastElement {}; set newSplitList {}; set skipP 0
  foreach element $splitList {
    if {$printP} { 
      puts stderr "lastElement `$lastElement' element `$element'"
    }
    if {($lastElement == "rightBrace") && \
            ($element == "else leftBrace")} {
      lappend newSplitList [concat $lastElement $element]
      set skipP 1
    } else {
      if {$skipP} {
        set skipP 0
      } else {
        lappend newSplitList $lastElement
      }
    }
    set lastElement $element 
  }
  lappend newSplitList $lastElement
  if {$printP} { 
    puts stderr "convertJmplToTclPrepare: merge leftBrace & `else rightBrace'"
    foreach el $newSplitList {
      puts stderr "`$el'"
    }
  }

  set errorMsg ""
  foreach element $newSplitList {
    set len [llength $element]
    if {$printP} { 
      puts stderr "convertJmplToTclPrepare: len $len element $element"
    }
    set errorMsg [convertJmplToTclDoit element newForm level variableList]
    if {$errorMsg != ""} {
      break
    }
  }
  if {$errorMsg != ""} {
    return "error: $errorMsg"
  } else {
    # convert embedded .'s to underscores in newForm so TCL will like it
    set newVariableList {}
    foreach var $variableList {
      if {[regexp "\\\." $var]} {
        regsub -all "\\\." $var "_" newVar
        lappend newVariableList $newVar 
        regsub -all [getMplRegExpression $var] $newForm $newVar tmp
        set newForm $tmp
      } else {
        lappend newVariableList $var
      }
    }
    if {($nodeClassType == "component") && \
            ($g_NM_selectedTestScopeRoot != "component") && \
            ([lsearch -exact $newVariableList "mode"] == -1)} {
      lappend newVariableList "mode"
      lappend variableList "mode"
    }
    # variableList keeps .'s so that values can be found
    set procForm "proc getDisplayState \{ $newVariableList \} \{\n"
    # do this so that if var values are not handled by newForm,
    #  displayState will still be defined
    append procForm "set displayState \"indeterminate\"\n"
    if {($nodeClassType == "component") && \
            ($g_NM_selectedTestScopeRoot != "component")} {
      # if any proc args unknownL2Value
      foreach var $newVariableList {
        append procForm "if \{$"
        append procForm "$var == \"unknown\"\} \{\n"
        append procForm "  set displayState \"unknownL2Value\"\n"
        append procForm "return $"
        append procForm "displayState\n\}\n"
      }
    }
    append procForm $newForm
    append procForm "return $"
    append procForm "displayState\n\}"
    if {$printP} {
      puts stderr "procForm `$procForm'"
    }
    return $procForm
  }
}


## this is a reserved proc name used by convertJmplToTcl
proc getDisplayState { } {
}


proc convertJmplToTclDoit { elementRef newFormRef levelRef variableListRef } {
  upvar $elementRef element
  upvar $newFormRef newForm
  upvar $levelRef level
  upvar $variableListRef variableList

  incr level
  set inIfFormP 0
  if {[llength $element] == 0} {
    # blank line - do nothing
    return ""
  } elseif {[llength $element] == 1} {
    # else  \{  \}
    if {$element == "leftBrace"} {
      append newForm " \{\n"
    } elseif {$element == "rightBrace"} {
      append newForm "\}\n"
    } elseif {$element == "else"} {
      append newForm " $element "
    } else {
      append newForm "$element \n"
    }
    return ""

  } elseif {([llength $element] == 2)} {
    # if {mode = off }
    # else \{
    if {[lindex $element 0] == "if"} {
      append newForm "[lindex $element 0] \{"
      set inIfFormP 1
      set conditional [lindex $element 1]
      # puts stderr "len conditional [llength $conditional]"
      if {[llength $conditional] < 3} {
        # mybe mode=off, which is one token
        return "conditional `$conditional' needs whitespace around operator"
      }
      # may be complex form with & and |
      set op "base"
      set opList [list "|" "&" "base"]
      while {$op != ""} {
        set subform [lrange $conditional 0 2]
        # puts stderr "  op `$op' subform `$subform' len [llength $subform]"
        if {[lsearch -exact $opList $op] >= 0} {
          if {$op != "base"} {
            append newForm "$op "
          }
        } else {
          return "invalid operator `$op' -- whitespace needed around operators"
        }
        set op [lindex $conditional 3]
        set conditional [lrange $conditional 4 end]
        set variable [lindex $subform 0]
        if {[lsearch -exact $variableList $variable] == -1} {
          lappend variableList $variable
        }
        append newForm "$[lindex $subform 0] "
        if {[lindex $subform 1] == "="} {
          append newForm "== "
        } else {
          append newForm [lindex $subform 1] 
        }
        append newForm "\"[lindex $subform 2]\" "
        if {$op == ""} {
          break
        }
      }
      append newForm "\} "
    } elseif {[lindex $element 0] == "else"} {
      append newForm "[lindex $element 0] "
      if {[lindex $element 1] == "leftBrace"} {
        append newForm " \{\n"
      } else {
        return "len = 2 2nd el [lindex $element 1] \nelement `$element'"
      }
    } else {
      return "len = 2 operator [lindex $element 0] \nelement `$element'"
    }
    return ""

  } elseif {[llength $element] == 3} {
    # if \{ q = w \} \{
    set operator [lindex $element 0]
    # puts stderr "len = 3: operator `$operator' element `$element'"
    if {$operator == "if"} {
      set subElement [lrange $element 0 1] 
      set errorMsg [convertJmplToTclDoit subElement newForm level variableList]
      if {$errorMsg != ""} {
        return $errorMsg
      }
      set subElement [lindex $element 2] 
      set errorMsg [convertJmplToTclDoit subElement newForm level variableList]
      if {$errorMsg != ""} {
        return $errorMsg
      }
    } elseif {($operator == "rightBrace") && \
                  ([lindex $element 1] == "else") && \
                  ([lindex $element 2] == "leftBrace")} {
      append newForm "\} else \{\n"
    } else {      
      # displayState = on
      set arg1 [lindex $element 1]
      set arg2 [lindex $element 2]
      # puts stderr "operator $operator arg1 $arg1 arg2 $arg2 arg3 $arg3"
      append newForm "set $operator "
      if {[regexp "\\\." $arg2]} {
        # this is a variable
        append newForm "$$arg2 \n"
        if {[lsearch -exact $variableList $arg2] == -1} {
          lappend variableList $arg2
        }
      } else {
        # this is a constant
        append newForm "\"$arg2\" \n"
      }
    }
    return ""
  } else {
    return "length [llength $element] not handled \nelement `$element'"
  }
}










